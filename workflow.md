Full workflow of a radio station
================================

This chapter essentially follows [the introductory chapter](#chap:quickstart),
but gives much more details about techniques and parameters one can use to
achieve his goals.

Sound inputs
------------

### Soundcard inputs

In order to input from a soundcard you should use `input.alsa`, or
`input.pulseaudio` which might use other libraries and be more portable. For
instance, you can hear your voice with

```{.liquidsoap include="liq/mic.liq" from=1}
```

Here, we have to use `buffer` in order to deal with synchronization issues
between the input and the output as detailed in [there](#sec:clocks).

If you want to use a particular device, you should use the parameter `device`
which takes as argument a string of the form `hw:X,Y` where `X` is the card
number and `Y` is the device number. The list of all devices available on your
computer can be obtained with the command

```
aplay -l
```

On my computer this returns

```
card 0: PCH [HDA Intel PCH], device 0: ALC3246 Analog [ALC3246 Analog]
  Subdevices: 0/1
  Subdevice #0: subdevice #0
card 0: PCH [HDA Intel PCH], device 3: HDMI 0 [HDMI 0]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
```

so that if I want to input from HDMI, I should use `hw:0,3` as `device`
parameter for `input.alsa`.

By default, the ALSA operators have an internal buffer in order to be able to
cope with small delays induced by the soundcard and the computer. However, you
can set the `bufferize` parameter to `false` in order to avoid that in order to
reduce latencies. For instance, if you are lucky, you can hear your voice
almost in realtime, with some flanger effect just for fun:

```{.liquidsoap include="liq/alsa-realtime.liq" from=1}
```

Beware that by reducing the buffers, you are likely to hear audio glitches due
to the fact that blank is inserted when audio data is not ready soon enough. In
this case, you should also see the following in the logs:

```
Underrun! You may minimize them by increasing the buffer size.
```

Again other libraries other than ALSA are also available for soundcard input in
Liquidsoap, so that you have multiple possibilities if you have problems with
one of them: `input.oss`, `input.portaudio` and `input.pulseaudio` (the latest
one being the most widely spread one).

### External input

In case you are still not satisfied (for instance, if you have very specific
needs or not widely supported hardware), it is possible to use any program as an
input, as long as this program echoes on its standard output either in wav
format (with the `input.external.wav` operator) or raw audio (with the
`input.external.rawaudio` operator). For instance, we can play a sine wave which
is generated by the program `ffmpeg` with:

```{.liquidsoap include="liq/input.external.liq" from=1 to=-1}
```

The argument is the program which is going to be executed: here it is `ffmpeg`
instructed to generate a sine at 440 Hz of duration 5 in stereo, encode it in
wav format, and output it in standard output.

Also, if the other program has support for it, it is possible to use
Jack\index{Jack} with the `input.jack` operator. This library is dedicated to
the communication of audio data between programs and greater stability and
precision is expected than with the above method. We do not detail it here,
because it involves some configuration (in particular, a dedicated Jack server
should be running) which is not specific to Liquidsoap.

### GStreamer input

Another very general possibility for input is to use the `input.gstreamer.audio`
operator in order to use the GStreamer\index{GStreamer} library to generate
audio. The generation itself is described through a _pipeline_ which consists in
a sequence of GStreamer operators, we refer the reader to the documentation of
the library for more information about it. Here, it can be passed in the
argument labeled `pipeline`, as expected. For instance, we can generate a sine
wave (again) with

```{.liquidsoap include="liq/input.gstreamer.liq" from=1 to=-1}
```

or we can play the file `test.mp3` with

```{.liquidsoap include="liq/input.gstreamer2.liq" from=1 to=-1}
```

In practice, no one would use the above example as is, because Liquidsoap
already has builtin support for using GStreamer to decode files...

File inputs
-----------

### Playlists

A radio generally starts with a playlist, which is a list of files to play. The
`playlist`\index{playlist@\texttt{playlist}} operator does that: it takes as
argument either a playlist or a directory (in which case the playlist will
consist of all the files in the directory). For instance,

```{.liquidsoap include="liq/playlist.liq" from=1}
```

The playlists generally contains one file per line, such as

```
/data/mp3/file1.mp3
/data/mp3/file2.mp3
/data/mp3/file3.mp3
http://server/file.mp3
ftp://otherserver/file.mp3
```

but other more advanced playlist formats are also supported: pls, m3u, asx,
smil, xspf, rss podcasts, etc. By default, the files are played in a random
order but this can be changed with the `mode` parameter of `playlist` which can
either be

- `"normal"`: play files in order,
- `"randomize"`: play files in a random order chosen for the whole playlist at
  each round (default mode),
- `"random"`: pick a random file each time in the playlist (there could thus be
  repetitions in files).
  
By default, the playlist is never reloaded, but this can be changed by using the
parameters `reload` and `reload_mode`, for instance:

- reload the playlist every hour (1 hour being 3600 seconds):
  
  ```liquidsoap
  s = playlist(reload=3600, reload_mode="seconds", "playlist")
  ```

- reload the playlist after each round (when the whole playlist has been played):

  ```liquidsoap
  s = playlist(reload=1, reload_mode="rounds", "playlist")
  ```
  
- reload the playlist whenever it changes (this requires Liquidsoap being
  compiled with support for the inotify library):

  ```liquidsoap
  s = playlist(reload_mode="watch", "playlist")
  ```

Another useful option is `check_next`, to specify a function which will
determine whether a file should be played or not in the playlist (this function
takes a request as argument and returns a boolean). For instance, we can ensure
that only the files whose name end in ".mp3" are played with

```{.liquidsoap include="liq/playlist-check.liq" from=1 to=-1}
```

(you could also typically make you decision based on the metadata of the
request, which can be obtained with `request.metadata`). If you only need to
play one file, then you can avoid creating a playlist with this file only, by
using the operator `single` which loops on one file (it is also more efficient
in the case the file is distant because it is downloaded once for all):

```liquidsoap
s = single("http://server/file.mp3")
```

By the way, if you do not want to loop over and over the file, and only play it
once, you can use the operator `once` which takes a source as argument and plays
one song of this source (it becomes unavailable after that).

```liquidsoap
s = once(single("http://server/file.mp3"))
```

### Distant streams

The operators `single` or `playlist` make sure in advance that the file to be
played is available: in particular, it downloads distant files so that they are
ready when we need them. Because of this, they are not suitable in order to play
streams (which are very long, or even infinite), because Liquidsoap would try to
download them all before reading them.

In order to play a stream, the `input.http` operator should be used:

```{.liquidsoap include="liq/input.http.liq" from=1 to=-1}
```

This operator works with streams such as those generated by Icecast, but also
for playlists containing streams. It will regularly pull data from the given
location, and therefore should be used for locations that are assumed to be
available most of the time. If not, it might generate unnecessary traffic and
polute the logs: in this case, it is perhaps better to inverse the paradigm and
use the `input.harbor` operator described below. If the stream is using secure
http protocol (if the URI starts with `https://...`), the operator `input.https`
should be used instead.

Also, streams in HLS format are quite different from the above, and are
therefore handled by a different operator, `input.hls`:

```{.liquidsoap include="liq/input.hls.liq" from=1 to=-1}
```

In this protocol the stream is segmented in small files and Liquidsoap will
regularly look for new segments (how often can be controlled by the `reload`
parameter).

### Interactive playlists {#sec:request.dynamic}

Instead of having a static playlist, you might want to use you own script to
generate the song which should be played next (e.g. you might fetch requests
from users from the web, or you might have a neural network deciding for you
which song is the best to be played next). In this case you should use
`request.dynamic`, which takes as argument a function returning the next song to
be played. This function has type `() -> request('a)`, meaning that it takes no
argument and returns a request. For instance, suppose that we have a script
called `next-song`, which echoes the next song to be played on the standard
output. A degenerate example of such a script could be

```{.bash include="liq/next-song"}
```

which always returns `test.mp3` as song to be played. We can then query this
script in order to play song as follows:

```{.liquidsoap include="liq/request.dynamic.liq" from=1 to=-1}
```

Here, our next function executes the script `next-song` using the function
`get_process_lines` which returns the list of lines returns by the script. We
then take the first line (`list.hd`) and return a request from created from it
using `request.create`.

### Request queues {#sec:request.queue}

In interactive playlist, the operator asks for the next song. But in some
situations, instead of this passive way of proceeding (you are asked for songs),
you would rather have an active way of proceeding (you inform the operator of
new files when you have some). Typically, if you have a website where users can
request songs, you would like to be able to put the requested song in a playlist
at the moment the user requests it. This is precisely the role of the
`request.queue` operator, which maintains a list of songs to be played in a
queue (the songs are played in the order they are pushed). A typical setup
involving this operator would be the following:

```{.liquidsoap include="liq/request.queue.liq" from=1}
```

We have both a playlist and a queue, and the radio plays queue, or the playlist
by default (when there is no song in the queue). You might wonder then: how do
we add new songs in the queue? The role of the first line is to instruct
Liquidsoap to start a server, which is listening by default on port 1234, on
which commands can be sent; we refer the reader to [this section](#sec:telnet)
for details about this telnet server. The queue will register a new command on
this server so that if you connect to it and write `queue.push` followed by an
uri, it will be pushed into the queue. In practice this can be done with
commands such as

```
echo "queue.push test.mp3" | nc localhost 1234
```

which uses the standard unix tool `nc` to connect to the server on supposed to
be running on the local host on port 1234, and write the command `queue.push
test.mp3` on this server, to which it will react by adding the song "`test.mp3`"
on the queue. If you have multiple queues in your script, you will certainly
want to specify the `id` parameter of `request.queue`, which can be any string
you want, so that the command will be `id.push` (where `id` is replaced by the
id you specified) and you know in which queue you are pushing.

It is also possible to push a request into the queue directly from Liquidsoap by
using the function `request.queue.pushable`, which acts exactly as the function
`request.queue` excepting that it returns a pair consisting of a function of
type `(request('a)) -> unit` and a source, instead of a source only. The
function can then be used to push a request in the queue at any time. For
instance, the following script is a variant of the previous one:

```{.liquidsoap include="liq/request.queue.pushable.liq" from=1}
```

As explained above, the function `request.queue.pushable` returns the function
`push` to push into the queue in addition to the source, we then use the
function `exec_at` to run at every minute (i.e. when the current second is 0)
the function which pushes the request to say "A new minute has passed".\SM{is
this clear?}

Incidentally, the functions `request.queue` and `request.queue.pushable` are
implemented in Liquidsoap, by using a list to maintain the queue of
requests. Here is a (simplified version of) the implementation of
the second:

```{.liquidsoap include="liq/request.queue.pushable-implementation.liq" from=1 to=-1}
```

Internally, it maintains a reference on a list called `queue`. The `next`
function pops the first element of the list and returns it and the `push` adds a
new request at the end of the list. Finally, the source is created by
`request.dynamic` with `next` as function returning the next request; note that
we use the labeled argument `available` which is a boolean getter indicating
whether or not the function `next` has a meaningful next request to answer (it
does not when the list is empty). Finally, both the function `push` and the
source a returned.

### Protocols

We have seen that playlists can either contain files which are local or distant,
the latter beginning by prefixes such as "`http:`" or "`ftp:`". A _protocol_ is
a way of turning such a prefixed URI\SM{we should say early in the book what an
URI is} into an actual file. Most of the time it will consist in downloading the
file in the appropriate way but not only. Liquidsoap supports many protocols and
even the possibility of adding your own.

For instance, the `youtube-dl` protocol allows the use of the `youtube-dl`
program in order to download files from youtube.

```{.liquidsoap include="liq/youtube-dl.liq" from=1 to=-1}
```

Similarly, the `say` protocol uses the text-to-speech software `text2wav`
(provided by festival) in order to synthesize speech. For instance,

```{.liquidsoap include="liq/say.liq" from=1 to=-1}
```

Incidentally, the `prefix` parameter of `playlist` can be used to add a prefix
to every element of the playlist, which is typically useful for protocols. For
instance, the following will read out the paths of the file in the playlist:

```{.liquidsoap include="liq/say-playlist.liq" from=1 to=-1}
```

More powerful, the `process` protocol allows to launch any command in order to
process files. The syntax is

```
process:<ext>,<cmd>:uri
```

where `<ext>` is the extension of the produced file, `<cmd>` is the command to
launch and `uri` is the URI of a file. In `<cmd>`, `$(input)` will be replaced
by the input file and `$(output)` by the output file (a temporary file whose
extension is `<ext>`. For instance, we can convert a file `test.mp3` in stereo
wav (even if the input file is mono) by:

```{.liquidsoap include="liq/process1.liq" from=1 to=-1}
```

When playing it, Liquidsoap will first download `test.mp3` into some place (say
`/tmp/temp.mp3`) and then execute

```
ffmpeg -y -i /tmp/temp.mp3 -ac 2 /tmp/temp.wav
```

in order to convert it to stereo wav, and then play the resulting temporary file
`/tmp/temp.wav`. The protocol `process` also accepts files of the form

```
process:<ext>,<cmd>
```

in which case only `$(output)` will be replaced in the command. For instance,
the implementation of text-to-speech in Liquidsoap essentially amounts to doing

```{.liquidsoap include="liq/process2.liq" from=1 to=-1}
```

which will run

```
echo 'Hello world!' | text2wave > /tmp/temp.wav
```

and play the resulting file.

One of the most powerful features of Liquidsoap is that it gives you the ability
of registering your own protocols. For instance, suppose that we have a program
`find_by_artist` which takes as argument the name of an artist and prints a
lists of music files of this artist. This is typically done by looking into a
database of all your music files. For instance,

```
find_by_artist Halliday
```

will print

```
/data/mp3/allumer_le_feu.mp3
/data/mp3/l_envie.mp3
/data/mp3/que_je_t_aime.mp3
```

We can define a new protocol named `artist` so that when playing a file such as
`artist:Halliday`, Liquidsoap will run the above command in order to find a
song. This can be done by using the `add_protocol` operator: its first mandatory
argument is the name of the protocol (here, `artist`) and the second one is a
function which takes as arguments

- a function `rlog` to log the resolution process (you can use it to print
  whatever is useful for you to debug resolution problems),
- a duration `maxtime` in seconds which the resolution should not exceed (you
  should be careful about it when querying distant servers which might fail for
  instance),
- the request,

and returns a list of file names (which can use any protocol) which correspond
to the request (Liquidsoap will play one of them). In our case,

```{.liquidsoap include="liq/add_protocol2.liq" from=1 to=-3}
```

and we can finally play songs of any artist:

```liquidsoap
s = single("artist:Haliday")
```

TODO: some other useful predefined protocols:

- s3
- annotate (detailed below)
- There is a [list of
protocols](https://www.liquidsoap.info/doc-dev/protocols.html)


### Icecast inputs (harbor) {#sec:input.harbor}

Many programs are able to stream to a Liquidsoap server, and we can use those as
an input for Liquidsoap scripts with the `input.harbor` operator. It instructs
Liquidsoap to run an Icecast-compatible server, called for some reason
_harbor_. Clients can then connect to it, as they would do on any Icecast
server, and the stream they send there is then available as a source in your
script. This can be useful to relay a live stream without polling the Icecast
server for it, or if you have punctual distant interventions from live
speakers or DJs. A typical setup would be

```{.liquidsoap include="liq/input.harbor.liq" from=1}
```

In this example, we use the `playlist` source by default, but we give priority
to the `live` source, which is a harbor input, available only when some client
connects to it. Apart from the parameters specifying the port and the password
to use when connecting, the unlabeled argument specifies the _mountpoint_: this
should be specified by the client when connecting, which means that a same
harbor server can simultaneously relay multiple sources, as long as they have
different mountpoints (and the same mountpoint name on two harbor servers with
different ports are handled as different mountpoints).

#### Security

Since harbor exposes a server to the internet, you should be serious about
security and think thoroughly about who should be having access to this
server. The fact that the server is programmed in OCaml makes it very unlikely
that an exploit such as a buffer overflow is possible, but one never knows.

First the list of IPs which are allowed to connect to harbor can be changed with
the following setting:

```liquidsoap
set("harbor.bind_addrs", ["0.0.0.0"])
```

It takes as argument a list of allowed IPs, the default one 0.0.0.0 meaning that
every IP is allowed.

In practice, it is often quite difficult to know in advance the IPs of all the
clients, so that the main security is given by the password which is passed as
argument of `input.harbor`: please chose it wisely, and avoid at any means the
default password `"hackme"`. Even with a strong password, the security is not
very good: if some of the clients leaks the password or you want to revoke some
a client, you have to change it for every client which is not convenient. For
this reason, the authentication can also be done through a function, which is
passed as the `auth` argument of `input.harbor` and is of type `(string, string)
-> bool`: it takes as argument the username and the password of a client trying
to log in and returns whether it should be allowed or not. Typically, you would
like to call an external script, say `harbor-auth`, which will take the username
and password as argument and print "`allowed`" if the user is allowed.

```{.liquidsoap include="liq/input.harbor-auth.liq" from=1}
```

Here, our function `auth` begins by executing the script `harbor-auth` with the
username and password as argument. Note that we use `string.quote` to escape
shell special characters, so that the user cannot introduce shell commands in
his username for instance... The `get_process_lines` function returns the list
of lines returned by our script and our function returns `true` or `false`
depending on whether this first line is `"allowed"` or not. In this way you
could easily have an external database of allowed users.

Finally, the clients should be able to determine that they are really connected
with your server and not some hacker's one. The best way to achieve that is to
use SSL certificates, which can be handled with the `input.harbor.ssl` variant
of the harbor source (it is present only if Liquidsoap has been compiled with
SSL support). The certificate can be specified with the setting
`harbor.ssl.certificate` (the setting `harbor.ssl.private_key` can also be used
to specify the private key and `harbor.ssl.password` the password to unlock the
private key). Obtaining a proper SSL certificate can be tricky. You may want to
start with a self-signed certificate first, which you can for instance obtain
from [Let's Encrypt](https://letsencrypt.org/). Alternatively, a self-signed
certificate for local testing you can use the following one-liner:

```
openssl req -x509 -newkey rsa:4096 -sha256 -nodes -keyout server.key -out server.crt -subj "/CN=localhost" -days 3650
```

Scheduling
----------

Now that we have a wide panel of sources, we will study how to combine them.

### Fallback {#sec:fallback}

The first way of combining sources is through the `fallback` operator, which
takes as argument a list of sources, and plays the first one which is
available. We have already seen examples of this with request queues
([here](#sec:request.queue)) such as

```liquidsoap
radio = fallback([queue, playlist])
```

We want to play a song from the request queue when there is one, otherwise we
play songs from the playlist. By default, if we are playing a song from the
playlist and there is a new song in the queue, the operator will wait for the
current playlist song to finish before play the one from the queue. This
behavior can be changed by setting the `track_sensitive` parameter to `false`,
in which case the song from the queue will be immediately played. Such an
example was given for Icecast inputs ([here]{#sec:input.harbor}).

Incidentally, the `mksafe` operator which takes a fallible source and make it
infallible is implemented precisely using this operator:

```{.liquidsoap include="liq/mksafe.liq" from=1}
```

We make the source fallback on a source streaming blank audio, which we know
will always be available, so that we stream blank when the source `s` fails.

### Switching

Another way of selecting between sources is the `switch` operator which takes as
argument a list, whose elements are pairs consisting of a _predicate_ which is a
function taking no argument an returning a boolean (of type `() -> bool`), and a
source. The operator will then select the first source whose predicate returns
true. For instance, supposing that we have two different playlists for night and
day, we could alternate between those depending on the hour with

```{.liquidsoap include="liq/switch.liq" from=3 to=-1}
```

Again, the `track_sensitive` controls whether a change of source only occurs at
track boundaries (when `true` which is the default) or whenever possible.

We could also use this to manually switch between sources. As an illustration,
suppose that we have two radio streams named `radio1` and `radio2` then we could
use a script such as

```liquidsoap
radio = switch(track_sensitive=false, [(p, radio1), ({true}, radio2)])
```

where the predicate determines when `radio1` should be played. For instance, if
we want to play it when a file `select-radio` contains "`1`", we could define it
as

```liquidsoap
p = {file.contents("select-radio") == "1"}
```

Or we could use an interactive boolean (see [there](#sec:telnet) with

```liquidsoap
p = interactive.bool("radio1", false)
```

whose value can then be changed by issuing commands such as

```
echo "var.set radio1 = true" | nc localhost 1234
```

or directly connecting to the telnet server.

### Adding

Instead of switching between two sources, we can play them together with the
`add` operator, which takes a list of sources whose sound are to be added. For
instance, if we want to make a radio consisting of a microphone input together
with background music (which is often called a "bed"), we can define

```{.liquidsoap include="liq/add.liq" from=3 to=-1}
```

TODO: weights


```{.liquidsoap include="liq/add2.liq" from=3 to=-1}
```

TODO: normalize, equivalence with `amplify`

```{.liquidsoap include="liq/add3.liq" from=3 to=-1}
```

### Jingles

```liquidsoap
# Add a jingle to your normal source
# at the beginning of every hour:
add([normal,switch([({0m0s},jingle)])])
```

It can be useful to have a special playlist that is played at least every 20
minutes for instance (3 times per hour). You may think of a promotional playlist
for instance. Here is the recipe:

```liquidsoap
# (1200 sec = 20 min)
timed_promotions = delay(1200.,promotions)
main_source = fallback([timed_promotions,other_source])
```

TODO: jingle at fixed hour with `predicate.activates`

Suppose that we have a playlist `jingles` of jingles and we want to play one
within the 5 first minutes of every hour, without interrupting the current
song. We can think of doing something like

```liquidsoap
radio = switch([({ 0m-5m }, jingles), ({ true }, playlist)])
```

but the problem is that it is likely to play many jingles. In order to play
exactly one jingle, we can use the function `predicate.activates` which detects
when a predicate (here `{ 0m-5m }`) becomes true:

```liquidsoap
radio = switch([(predicate.activates({ 0m-5m }), jingles), ({ true }, playlist)])
```


### Live shows

Switch to a live show as soon as one is available. Make the show unavailable
when it is silent, and skip tracks from the normal source if they contain too
much silence.

```liquidsoap
stripped_stream = 
  strip_blank(input.http("http://myicecast:8080/live.ogg"))
fallback(track_sensitive=false,
         [stripped_stream,skip_blank(normal)])
```

Without the `track_sensitive=false` the fallback would wait the end of a track
to switch to the live. When using the blank detection operators, make sure to
fine-tune their threshold and length (float) parameters.

### Interactive values {#sec:telnet}

- switching with telnet (= switch on a boolean set via telnet)
- OSC (e.g. a switch, a volume)

There are two kinds of transitions. Transitions between two different children of a switch are not problematic. Transitions between different tracks of the same source are more tricky, since they involve a fast forward computation of the end of a track before feeding it to the transition function: such a thing is only possible when only one operator is using the source, otherwise it'll get out of sync.

##### Switch-based transitions
The switch-based operators (`switch`, `fallback` and `random`) support transitions. For every child, you can specify a transition function computing the output stream when moving from one child to another. This function is given two `source` parameters: the child which is about to be left, and the new selected child. The default transition is `fun (a,b) -> b`, it simply relays the new selected child source.

Transitions have limited duration, defined by the `transition_length` parameter. Transition duration can be overriden by passing a metadata. Default field for it is `"liq_transition_length"` but it can also be set to a different value via the `override` parameter. 

Here are some possible transition functions:

```
# A simple (long) cross-fade
# Use metadata override to make sure transition is long enough.
def crossfade(a,b)
  def add_transition_length(_) =
    [("liq_transition_length","15.")]
  end

  transition =
    add(normalize=false,
          [ sequence([ blank(duration=5.),
                       fade.in(duration=10.,b) ]),
            fade.out(duration=10.,a) ])

  # Transition can have multiple tracks so only pass the metadata
  # once.
  map_first_track(map_metadata(add_transition_length),transition)
end

# Partially apply next to give it a jingle source.
# It will fade out the old source, then play the jingle.
# At the same time it fades in the new source.
# Use metadata override to make sure transition is long enough.
def next(j,a,b)
  # This assumes that the jingle is 6 seconds long
  def add_transition_length(_) =
    [("liq_transition_length","15.")]
  end

  transition =
    add(normalize=false,
	  [ sequence(merge=true,
	             [ blank(duration=3.),
	               fade.in(duration=6.,b) ]),
	    sequence([fade.out(duration=9.,a),
	              j,blank()]) ])

  map_first_track(map_metadata(add_transition_length),transition)
end

# A transition, which does a cross-fading from A to B
# No need to override duration as default value (5 seconds)
# is over crossade duration (3 seconds)
def transition(j,a,b)
  add(normalize=false,
	  [ fade.in(duration=3.,b),
	    fade.out(duration=3.,a) ])
end
```

Finally, we build a source which plays a playlist, and switches to the live show as soon as it starts, using the `transition` function as a transition. At the end of the live, the playlist comes back with a cross-fading.

```
fallback(track_sensitive=false,
	     transitions=[ crossfade, transition(jingle) ],
	     [ input.http("http://localhost:8000/live.ogg"),
	       playlist("playlist.pls") ])
```

##### Cross-based transitions
The `cross()` operator allows arbitrary transitions between tracks of a same source. Here is how to use it in order to get a cross-fade:

```
def crossfade(~start_next,~fade_in,~fade_out,s)
  fade.in = fade.in(duration=fade_in)
  fade.out = fade.out(duration=fade_out)
  fader = fun (_,_,_,_,a,b) -> add(normalize=false,[fade.in(b),fade.out(a)])
  cross(duration=start_next,fader,s)
end
my_source =
  crossfade(start_next=1.,fade_out=1.,fade_in=1.,my_source)
```

The `crossfade()` function is already in liquidsoap. Unless you need a custom one, you should never have to copy the above example. It is implemented in the scripting language, much like this example. You can find its code in `utils.liq`.

The fade-in and fade-out parameters indicate the duraction of the fading effects. The start-next parameters tells how much overlap there will be between the two tracks. If you want a long cross-fading with a smaller overlap, you should use a sequence to stick some blank section before the beginning of `b` in `fader`.
The three parameters given here are only default values, and will be overriden by values coming from the metadata tags `liq_fade_in`, `liq_fade_out` and `liq_start_next`.

For an advanced crossfading function, you can see the [crossfade documentation](crossfade.html)







Handling tracks
---------------

### Metadata

- log all the music files which have gone on air
```{.liquidsoap include="liq/log_songs.liq" from=1 to=-1}
```
- log the current file in JSON format (see #954)
```liquidsoap
s = mksafe(playlist("~/Music"))

def f(m)
  print("got metadata!")
  data = json_of(m)^"\n"
  ignore(file.write(data=data, append=false, perms=420, "/tmp/metatest"))
end

s = on_metadata(f, s)
out(s)
```
- count the number of played music files (a reference!)
- say the last song we had on air
- the annotate protocol

*ICY metadata* is the name for the mechanism used to update
metadata in icecast's source streams.
The techniques is primarily intended for data formats that do not support in-stream
metadata, such as mp3 or AAC. However, it appears that icecast also supports
ICY metadata update for ogg/vorbis streams.

When using the ICY metadata update mechanism, new metadata are submitted separately from
the stream's data, via a http GET request. The format of the request depends on the
protocol you are using (ICY for shoutcast and icecast 1 or HTTP for icecast 2).

Starting with 1.0, you can do several interesting things with icy metadata updates
in liquidsoap. We list some of those here.

You can enable or disable icy metadata update in `output.icecast`
by setting the `icy_metadata` parameter to either `"true"`
or `"false"`. The default value is `"guess"` and does the following:

* Set `"true"` for: mp3, aac, aac+, wav
* Set `"false"` for any format using the ogg container

You may, for instance, enable icy metadata update for ogg/vorbis
streams.

The function `icy.update_metadata` implements a manual metadata update
using the ICY mechanism. It can be used independently from the `icy_metadata`
parameter described above, provided icecast supports ICY metadata for the intended stream.

For instance the following script registers a telnet command name `metadata.update`
that can be used to manually update metadata:

```
def icy_update(v) =
  # Parse the argument
  l = string.split(separator=",",v)
  def split(l,v) =
    v = string.split(separator="=",v)
    if list.length(v) >= 2 then
      list.append(l,[(list.nth(v,0,default=""),list.nth(v,1,default=""))])
    else
      l
    end
  end
  meta = list.fold(split,[],l)

  # Update metadata
  icy.update_metadata(mount="/mystream",password="hackme",
                      host="myserver.net",meta)
  "Done !"
end

server.register("update",namespace="metadata",
                 description="Update metadata",
                 usage="update title=foo,album=bar,..",
                 icy_update)
```

As usual, `liquidsoap -h icy.update_metadata` lists all the arguments
of the function.

### Annotate

TODO: annotate protocol, mention the `prefix` parameter of `playlist`

Transitions {#sec:transitions}
-----------

### Crossfade

crossfade
annotate, cue_in cue_out

Sources that support seeking can also be used to implement cue points.
The basic operator for this is `cue_cut`. Its has type:

```
(?id:string,?cue_in_metadata:string,
 ?cue_out_metadata:string,
 source(audio='#a,video='#b,midi='#c))->
    source(audio='#a,video='#b,midi='#c)
```

Its parameters are:

* `cue_in_metadata`: Metadata for cue in points, default: `"liq_cue_in"`.
* `cue_out_metadata`: Metadata for cue out points, default: `"liq_cue_out"`.
* The source to apply cue points to.

The values of cue-in and cue-out points are given in absolute
position through the source's metadata. For instance, the following
source will cue-in at 10 seconds and cue-out at 45 seconds on all its tracks:

```
s = playlist(prefix="annotate:liq_cue_in=\"10.\",liq_cue_out=\"45\":",
             "/path/to/music")

s = cue_cut(s)
```

As in the above example, you may use the `annotate` protocol to pass custom cue
points along with the files passed to Liquidsoap. This is particularly useful 
in combination with `request.dymanic` as an external script can build-up
the appropriate URI, including cue-points, based on information from your
own scheduling back-end.

Alternatively, you may use `map_metadata` to add those metadata. The operator
`map_metadata` supports seeking and passes it to its underlying source.

### Other operators

mention the `transitions` parameter of `fallback`, e.g. for nice switching to
live


Signal processing
-----------------

### Normalization

normalization, replaygain (the protocol)

LADSPA plugins

Good examples:

- https://savonet-users.narkive.com/MiNy36h8/have-a-sort-of-fm-sound-with-liquidsoap

### Blank

The various functions to remove blank

### Parameters

We can obtain parameters through telnet or OSC

### Stereotool

TODO.......

Outputs
-------

### Files

`output.file`, common encoding formats

It is sometimes useful (or even legally necessary) to keep a backup of an audio
stream. Storing all the stream in one file can be very impractical. In order to
save a file per hour in wav format, the following script can be used:

```
# A source to dump
# s = ...

# Dump the stream
file_name = '/archive/$(if $(title),"$(title)","Unknown archive")-%Y-%m-%d/%Y-%m-%d-%H_%M_%S.mp3'
output.file(%mp3,filename,s)
```

This will save your source into a `mp3` file with name specified by `file_name`.
In this example, we use [string interpolation](language.html) and time litterals to generate a different
file name each time new metadata are coming from `s`.


### Icecast

mention `output.harbor`

### HLS output

TODO: multiple qualities, we can convert to mono with `mean`

Monitoring the stream
---------------------

See above for logging tracks

Use `on_blank` to detect blank...

Some telnet (e.g. know the current song for a source, etc.)


On GeekRadio, we play many files, some of which include bonus tracks, which
means that they end with a very long blank and then a little extra music. It's
annoying to get that on air. The `skip_blank` operator skips the
current track when a too long blank is detected, which avoids that. The typical
usage is simple:

```liquidsoap
# Wrap it with a blank skipper
source = skip_blank(source)
```

At [RadioPi](http://www.radiopi.org/) they have another problem: sometimes they
have technical problems, and while they think they are doing a live show,
they're making noise only in the studio, while only blank is on air; sometimes,
the staff has so much fun (or is it something else ?) doing live shows that they
leave at the end of the show without thinking to turn off the live, and the
listeners get some silence again. To avoid that problem we made the
`strip_blank` operators which hides the stream when it's too blank
(i.e. declare it as unavailable), which perfectly suits the typical setup used
for live shows:

```liquidsoap
interlude = single("/path/to/sorryfortheblank.ogg")
# After 5 sec of blank the microphone stream is ignored,
# which causes the stream to fallback to interlude.
# As soon as noise comes back to the microphone the stream comes
# back to the live -- thanks to track_sensitive=false.
stream = fallback(track_sensitive=false,
	              [ strip_blank(max_blank=5.,live) , interlude ])

# Put that stream to a local file
output.file(%vorbis, "/tmp/hop.ogg", stream)
```

If you don't get the difference between these two operators, you should learn
more about liquidsoap's notion of [source](sources.html).

Finally, if you need to do some custom action when there's too much blank, we
have `on_blank`:

```liquidsoap
def handler()
  system("/path/to/your/script to do whatever you want")
end
source = on_blank(handler,source)
```




Clocks {#sec:clocks}
------

Explain the problem with multiple icecast outputs.

In the [quickstart](quick_start.html) and in the introduction to liquidsoap
[sources](sources.html), we have described a simple world in which sources
communicate with each other, creating and transforming data that
composes multimedia streams.
In this simple view, all sources produce data at the same rate,
animated by a single clock: at every cycle of the clock,
a fixed amount of data is produced.

While this simple picture is useful to get a fair idea of what's going on
in liquidsoap, the full picture is more complex: in fact, a streaming
system might involve *multiple clocks*, or in other words several
time flows.

It is only in very particular cases that liquidsoap scripts
need to mention clocks explicitly. Otherwise, you won't even notice
how many clocks are involved in your setup: indeed, liquidsoap can figure
out the clocks by itself, much like it infers types.
Nevertheless, there will sometimes be cases where your script cannot
be assigned clocks in a correct way, in which case liquidsoap will
complain. For that reason, every user should eventually get a minimum
understanding of clocks.

In the following, we first describe why we need clocks.
Then we go through the possible errors that any user might encounter
regarding clocks.
Finally, we describe how to explicitly use clocks,
and show a few striking examples of what can be achieved that way.

### Why multiple clocks

The first reason is **external** to liquidsoap: there is simply
not a unique notion of time in the real world.
Your computer has an internal clock which indicates
a slightly different time than your watch or another computer's clock.
Moreover, when communicating with a remote computer, network
latency causes extra time distortions.
Even within a single computer there are several clocks: notably, each
soundcard has its own clock, which will tick at a slightly different
rate than the main clock of the computer.
Since liquidsoap communicates with soundcards and remote computers,
it has to take those mismatches into account.

There are also some reasons that are purely **internal** to liquidsoap:
in order to produce a stream at a given speed,
a source might need to obtain data from another source at
a different rate. This is obvious for an operator that speeds up or
slows down audio (`stretch`). But it also holds more subtly
for `cross`, `cross` as well as the
derived operators: during the lapse of time where the operator combines
data from an end of track with the beginning of the other other,
the crossing operator needs twice as much stream data. After ten tracks,
with a crossing duration of six seconds, one more minute will have
passed for the source compared to the time of the crossing operator.

In order to avoid inconsistencies caused by time differences,
while maintaining a simple and efficient execution model for
its sources, liquidsoap works under the restriction that
one source belongs to a unique clock,
fixed once for all when the source is created.

The graph representation of streaming systems can be adapted
into a good representation of what clocks mean.
One simply needs to add boxes representing clocks:
a source can belong to only one box,
and all sources of a box produce streams at the same rate.
For example, 

```liquidsoap
output.icecast(fallback([crossfade(playlist(...)),jingles]))
```

yields the following graph:

![Graph representation with clocks](images/graph_clocks.png)

Here, clock_2 was created specifically for the crossfading
operator; the rate of that clock is controlled by that operator,
which can hence accelerate it around track changes without any
risk of inconsistency.
The other clock is simply a wallclock, so that the main stream
is produced following the ``real'' time rate.

### Error messages
Most of the time you won't have to do anything special about clocks:
operators that have special requirements regarding clocks will do
what's necessary themselves, and liquidsoap will check that everything is 
fine. But if the check fails, you'll need to understand the error,
which is what this section is for.

#### Disjoint clocks
On the following example, liquidsoap will issue the fatal error
`a source cannot belong to two clocks`:

```liquidsoap
s = playlist("~/media/audio")
output.alsa(s) # perhaps for monitoring
output.icecast(mount="radio.ogg",%vorbis,crossfade(s))
```

Here, the source `s` is first assigned the ALSA clock,
because it is tied to an ALSA output.
Then, we attempt to build a `crossfade` over `s`.
But this operator requires its source to belong to a dedicated
internal clock (because crossfading requires control over the flow
of the of the source, to accelerate it around track changes).
The error expresses this conflict:
`s` must belong at the same time to the ALSA clock
and `crossfade`'s clock.

##### Nested clocks
On the following example, liquidsoap will issue the fatal error
`cannot unify two nested clocks`:

```liquidsoap
jingles = playlist("jingles.lst")
music = rotate([1,10],[jingles,playlist("remote.lst")])
safe = rotate([1,10],[jingles,single("local.ogg")])
q = fallback([crossfade(music),safe])
```

Let's see what happened.
The `rotate` operator, like most operators, operates
within a single clock, which means that `jingles`
and our two `playlist` instances must belong to the same clock.
Similarly, `music` and `safe` must belong to that
same clock.
When we applied crossfading to `music`,
the `crossfade` operator created its own internal clock,
call it `cross_clock`,
to signify that it needs the ability to accelerate at will the
streaming of `music`.
So, `music` is attached to `cross_clock`,
and all sources built above come along.
Finally, we build the fallback, which requires that all of its
sources belong to the same clock.
In other words, `crossfade(music)` must belong
to `cross_clock` just like `safe`.
The error message simply says that this is forbidden: the internal
clock of our crossfade cannot be its external clock -- otherwise
it would not have exclusive control over its internal flow of time.

The same error also occurs on `add([crossfade(s),s])`,
the simplest example of conflicting time flows, described above.
However, you won't find yourself writing this obviously problematic
piece of code. On the other hand, one would sometimes like to
write things like our first example.

The key to the error with our first example is that the same
`jingles` source is used in combination with `music`
and `safe`. As a result, liquidsoap sees a potentially
nasty situation, which indeed could be turned into a real mess
by adding just a little more complexity. To obtain the desired effect
without requiring illegal clock assignments, it suffices to
create two jingle sources, one for each clock:

```liquidsoap
music = rotate([1,10],[playlist("jingles.lst"),
                       playlist("remote.lst")])
safe  = rotate([1,10],[playlist("jingles.lst"),
                       single("local.ogg")])
q = fallback([crossfade(music),safe])
```

There is no problem anymore: `music` belongs to 
`crossfade`'s internal clock, and `crossfade(music)`,
`safe` and the `fallback` belong to another clock.

#### The clock API
There are only a couple of operations dealing explicitly with clocks.

The function `clock.assign_new(l)` creates a new clock
and assigns it to all sources from the list `l`.
For convenience, we also provide a wrapper, `clock(s)`
which does the same with a single source instead of a list,
and returns that source.
With both functions, the new clock will follow (the computer's idea of)
real time, unless `sync=false` is passed, in which case
it will run as fast as possible.

The old (pre-1.0.0) setting `root.sync` is superseded
by `clock.assign_new()`.
If you want to run an output as fast as your CPU allows,
just attach it to a new clock without synchronization:

```liquidsoap
clock.assign_new(sync=false,[output.file(%vorbis,"audio.ogg",source)])
```

This will automatically attach the appropriate sources to that clock.
However, you may need to do it for other operators if they are totally
unrelated to the first one.

\TODO{mention the `buffer.adaptative` operator}
The `buffer()` operator can be used to communicate between
any two clocks: it takes a source in one clock and builds a source
in another. The trick is that it uses a buffer: if one clock
happens to run too fast or too slow, the buffer may empty or overflow.

Finally, `get_clock_status` provides information on
existing clocks and track their respective times:
it returns a list containing for each clock a pair
`(name,time)` indicating
the clock id its current time in *clock cycles* --
a cycle corresponds to the duration of a frame,
which is given in ticks, displayed on startup in the logs.
The helper function `log_clocks` built
around `get_clock_status` can be used to directly
obtain a simple log file, suitable for graphing with gnuplot.
Those functions are useful to debug latency issues.

### External clocks: decoupling latencies
The first reason to explicitly assign clocks is to precisely handle
the various latencies that might occur in your setup.

Most input/output operators (ALSA, AO, Jack, OSS, etc)
require their own clocks. Indeed, their processing rate is constrained
by external sound APIs or by the hardware itself.
Sometimes, it is too much of an inconvenience,
in which case one can set `clock_safe=false` to allow
another clock assignment --
use at your own risk, as this might create bad latency interferences.

Currently, `output.icecast` does not require to belong
to any particular clock. This allows to stream according to the
soundcard's internal clock, like in most other tools:
in

```liquidsoap
output.icecast(%vorbis,mount="live.ogg",input.alsa())
```
,
the ALSA clock will drive the streaming of the soundcard input via
icecast.

Sometimes, the external factors tied to Icecast output cannot be
disregarded: the network may lag. If you stream a soundcard input
to Icecast and the network lags, there will be a glitch in the
soundcard input -- a long enough lag will cause a disconnection.
This might be undesirable, and is certainly disappointing if you
are recording a backup of your precious soundcard input using
`output.file`: by default it will suffer the same
latencies and glitches, while in theory it could be perfect.
To fix this you can explicitly separate Icecast (high latency,
low quality acceptable) from the backup and soundcard input (low latency,
high quality wanted):

```liquidsoap
input = input.oss()

clock.assign_new(id="icecast",
  [output.icecast(%mp3,mount="blah",mksafe(buffer(input)))])

output.file(
  %mp3,"record-%Y-%m-%d-%H-%M-%S.mp3",
  input)
```

Here, the soundcard input and file output end up in the OSS
clock. The icecast output
goes to the explicitly created `"icecast"` clock,
and a buffer is used to
connect it to the soundcard input. Small network lags will be
absorbed by the buffer. Important lags and possible disconnections
will result in an overflow of the buffer.
In any case, the OSS input and file output won't be affected
by those latencies, and the recording should be perfect.
The Icecast quality is also better with that setup,
since small lags are absorbed by the buffer and do not create
a glitch in the OSS capture, so that Icecast listeners won't
notice the lag at all.

### Internal clocks: exploiting multiple cores
Clocks can also be useful even when external factors are not an issue.
Indeed, several clocks run in several threads, which creates an opportunity
to exploit multiple CPU cores.
The story is a bit complex because OCaml has some limitations on
exploiting multiple cores, but in many situations most of the computing
is done in C code (typically decoding and encoding) so it parallelizes
quite well.

Typically, if you run several outputs that do not share much (any) code,
you can put each of them in a separate clock.
For example the following script takes one file and encodes it as MP3
twice. You should run it as `liquidsoap EXPR -- FILE`
and observe that it fully exploits two cores:

```liquidsoap
def one()
  clock.assign_new(sync=false,
        [output.file(%mp3,"/dev/null",single(argv(1)))])
end
one()
one()
```

TODO: explain the operators who need to be clocked for instance, we had the
following question: Yamakaky [5:20 PM] Does `input.harbor` require the use of
`clock` and `buffer`? It has an internal buffer so I would say no?
