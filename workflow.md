Full workflow of a radio station {#chap:workflow}
================================

This chapter explains in details the main tools and techniques in order to setup
a webradio. It essentially follows [the introductory chapter](#chap:quickstart),
but gives much more details about techniques and parameters one can use to
achieve his goals.

Inputs
------

### Playlists

A radio generally starts with a playlist, which is simply a file listing files
to be played. The `playlist`\index{playlist@\texttt{playlist}} operator does
that: it takes as a playlist argument and plays it. For instance, the script

```{.liquidsoap include="liq/playlist2.liq" from=1}
```

will play all the files listed in the `my_playlist` playlist. The operator also
accepts a directory as argument, in which case the playlist will consist of all
the file in the directory: the script

```{.liquidsoap include="liq/playlist.liq" from=1}
```

will play all the files in the `Music` directory. The format of the playlists
generally consist in listing files, with one file per line, such as

```
/data/mp3/file1.mp3
/data/mp3/file2.mp3
/data/mp3/file3.mp3
http://server/file.mp3
ftp://otherserver/file.mp3
```

but other more advanced playlist formats are also supported: pls, m3u, asx,
smil, xspf, rss podcasts, etc. Those are generally created by using dedicated
software.

By default, the files are played in a random order but this can be changed with
the `mode` parameter of `playlist` which can either be

- `"normal"`: play files in order,
- `"randomize"`: play files in a random order chosen for the whole playlist at
  each round (default mode),
- `"random"`: pick a random file each time in the playlist (there could thus be
  repetitions in files).
  
By default, the playlist is never reloaded, but this can be changed by using the
parameters `reload` and `reload_mode`, for instance:

- reload the playlist every hour (1 hour being 3600 seconds):
  
  ```liquidsoap
  s = playlist(reload=3600, reload_mode="seconds", "playlist")
  ```

- reload the playlist after each round (when the whole playlist has been played):

  ```liquidsoap
  s = playlist(reload=1, reload_mode="rounds", "playlist")
  ```
  
- reload the playlist whenever it changes (this requires Liquidsoap being
  compiled with support for the inotify library):

  ```liquidsoap
  s = playlist(reload_mode="watch", "playlist")
  ```
  
\TODO{also present the reload method}

Another useful option is `check_next`, to specify a function which will
determine whether a file should be played or not in the playlist: this function
takes a request as argument and returns a boolean. For instance, we can ensure
that only the files whose name end in ".mp3" are played with

```{.liquidsoap include="liq/playlist-check.liq" from=1 to=-1}
```

The function `check` takes the request `r` given as argument, extracts its uri,
and then returns true or false depending on whether this uri ends with ".mp3" or
not. As another example, we can base our decision on the metadata of the file
as follows:


```{.liquidsoap include="liq/playlist-check2.liq" from=1 to=-1}
```

Here, we use the function `request.read_metadata` to force the reading of the
metadata for the request (this is not done by default at this point), obtain the
metadata with `request.metadata`, and declare that we should play a file only if
its genre is "Rock" (remember that the metadata are encoded as an association
list as explained in [there](#sec:association-list)).

If you only need to play one file, you can avoid creating a playlist with this
file only, by using the operator `single` which loops on one file. This operator
is also more efficient in the case the file is distant because it is downloaded
once for all:

```liquidsoap
s = single("http://server/file.mp3")
```

By the way, if you do not want to loop over and over the file, and only play it
once, you can use the operator `once` which takes a source as argument and plays
one song of this source (it becomes unavailable after that).

```liquidsoap
s = once(single("http://server/file.mp3"))
```

### Distant streams

The operators `playlist` or `single` make sure in advance that the file to be
played is available: in particular, they download distant files so that we are
sure that they are ready when we need them. Because of this, they are not
suitable in order to play continuous streams (which are very long, or even
infinite), because Liquidsoap would try to download them entirely before reading
them.

This is the reason why the `input.http` operator should be used in order to play
a stream:

```{.liquidsoap include="liq/input.http.liq" from=1 to=-1}
```

This operator works with streams such as those generated by Icecast, but also
with playlists containing streams. It will regularly pull data from the given
location, and therefore should be used for locations that are assumed to be
available most of the time. If not, it might generate unnecessary traffic and
pollute the logs: in this case, it is perhaps better to inverse the paradigm and
use the `input.harbor` operator described below, which allows the distant stream
to connect to Liquidsoap. If the stream is using secure http protocol (if the
uri starts with `https://...`), the operator `input.https` should be used
instead.

Streams in HLS format are quite different from the above (they consist of a
rolling playlist of short audio segments, see [there](#sec:HLS)) and are
therefore handled by a different operator, `input.hls`:

```{.liquidsoap include="liq/input.hls.liq" from=1 to=-1}
```

<!--
In this protocol the stream is segmented in small files and Liquidsoap will
regularly look for new segments (how often can be controlled by the `reload`
parameter).
-->

<!--
\TODO{polish this: we can use input.ffmpeg}
TODO: the format is optional and usually well detected, the list of supported formats can be obtained with `ffmpeg -formats`

```{.liquidsoap include="liq/input.ffmpeg-hls.liq"}
```
-->

### Interactive playlists {#sec:request.dynamic}

Instead of having a static playlist, you might want to use you own script to
generate the song which should be played next (e.g. you might fetch requests
from users from the web or a database, or you might have a neural network
deciding for you which song is the best to be played next). In this case you
should use `request.dynamic`, which takes as argument a function returning the
next song to be played. This function has type `() -> request('a)`, meaning that
it takes no argument and returns a request. For instance, suppose that we have a
script called `next-song`, which echoes the next song to be played on the
standard output. A degenerate example of such a script, using the shell, could
be

```{.bash include="liq/next-song"}
```

which always returns `test.mp3` as song to be played, but of course you could
use any program in any programming language as long as it outputs the file to be
played on the standard output. We can then query this script in order to play
song as follows:

```{.liquidsoap include="liq/request.dynamic.liq" from=1 to=-1}
```

Here, our `next` function executes the above script `next-song`, using the
function `get_process_lines` which returns the list of lines returns by the
script. We then take the first line with `list.hd` and return a request from
created from it using `request.create`. As a variant, suppose that the next song
to be played is present in a file named `song`. We can play it as follows:

```{.liquidsoap include="liq/request.dynamic2.liq" from=1 to=-1}
```

The `check` function now reads the contents of the file `song` and creates a
request from it. In the case were the file is empty there is no song to play,
and in this case we return the value `null` to indicate it. The `retry_delay`
parameter of `request.dynamic` indicates that, in this last case, we should wait
for 1 second before trying again. This example is not perfect: there is a chance
that a given song will be played multiple times if we don't update the file
`song` timely enough: we see a better way of achieving this kind of behavior in
next section.

### Request queues {#sec:request.queue}

In an interactive playlist, the operator asks for the next song. But in some
situations, instead of this passive way of proceeding (you are asked for songs),
you would rather have an active way of proceeding (you inform the operator of
new files when you have some). Typically, if you have a website where users can
request songs, you would like to be able to put the requested song in a playlist
at the moment the user requests it. This is precisely the role of the
`request.queue` operator, which maintains a list of songs to be played in a
queue (the songs are played in the order they are pushed). A typical setup
involving this operator would be the following:

```{.liquidsoap include="liq/request.queue.liq" from=1}
```

We have both a playlist and a queue, and the radio is defined by using the
`fallback` operator which tries to fetch the stream from the queue and if none
is available defaults to the playlist. The `track_sensitive=false` instructs
that we should play the stream from the queue as soon as it is available: by
default, `switch` will wait for the end of the current track before switching to
the queue.

#### Pushing songs in a queue

You might wonder then: how do we add new songs in the queue?  The role of the
first line is to instruct Liquidsoap to start a server, which is listening by
default on port 1234, on which commands can be sent; we refer the reader to
[this section](#sec:telnet) for details about this telnet server. The queue will
register a new command on this server so that if you connect to it and write
`queue.push` followed by an uri, it will be pushed into the queue. In practice
this can be done with commands such as

```
echo "queue.push test.mp3" | nc localhost 1234
```

which uses the standard unix tool `nc` to connect to the server on supposed to
be running on the local host on port 1234, and write the command `queue.push
test.mp3` on this server, to which it will react by adding the song "`test.mp3`"
on the queue.

If you have multiple queues in your script, you can specify their names by
specifying the `id` parameter of `request.queue`, which can be any string you
want, so that the command will be `id.push` (where `id` is replaced by the id
you specified) and you know in which queue you are pushing. For instance, in the
script

```{.liquidsoap include="liq/request.queues.liq" from=1}
```

the two queues are respectively called `q1` and `q2`, so that we can push a song
on the second queue by issuing the telnet command `q2.push file.mp3`.

It is also possible to push a request into the queue directly from Liquidsoap by
using the method `push` of a source defined by `request.queue` to push a request
on it, or the method `push.uri` to push an uri. For instance, consider the
following script

```{.liquidsoap include="liq/request.queue-push.liq" from=1}
```

It uses an auxiliary queue `q`, and uses the function `thread.run` to execute
every minute a function which pushes in to the queue the uri `"say:Another
minute has passed!"`. Because it begins by "`say:`" Liquidsoap will use a speech
synthesis software to turn the text into audio, as detailed below, and we will
hear "Another minute has passed" every minute, over the playlist (the `add`
operator plays simultaneously all the sources in its input list).

#### Implementation of queues

Incidentally, the function `request.queue` is implemented in Liquidsoap, by
using a list to maintain the queue of requests. Here is a slightly simplified
version of it:

```{.liquidsoap include="liq/request.queue-implementation.liq" from=1 to=-1}
```

Internally, it maintains a reference on a list called `queue`. The `next`
function pops the first element of the list and returns it (or `null` if the
queue is empty) and the `push` function adds a new request at the end of the
list. Finally, the source is created by `request.dynamic` with `next` as
function returning the next request; note that we use the labeled argument
`available` which is a boolean getter indicating whether or not the function
`next` has a meaningful next request to answer (it does not when the list is
empty). Finally, the source is returned, decorated with the method `push`.

### Protocols

We have seen that playlists can either contain files which are local or distant,
the latter beginning by prefixes such as "`http:`" or "`ftp:`". A _protocol_ is
a way of turning such a prefixed uri into an actual file. Most of the time it
will consist in downloading the file in the appropriate way, but not
only. Liquidsoap supports many protocols and even the possibility of adding your
own.

For instance, the `youtube-dl` protocol allows the use of the `youtube-dl`
program in order to download files from youtube.

```{.liquidsoap include="liq/youtube-dl.liq" from=1 to=-1}
```

when playing such a file, we need to do more than simply connect to some
particular location over the internet, and have to do tricky stuff in order to
fetch the video from youtube. Similarly, the `say` protocol uses the
text-to-speech software `text2wav` provided by the festival project in order to
synthesize speech. For instance,

```{.liquidsoap include="liq/say.liq" from=1 to=-1}
```

Incidentally, the `prefix` parameter of `playlist` can be used to add a prefix
to every element of the playlist, which is typically useful for
protocols. Typically, the following will read out the paths of the file in the
playlist:

```{.liquidsoap include="liq/say-playlist.liq" from=1 to=-1}
```

Another very useful protocol is `annotate` which adds metadata to the following
song, as in

```
annotate:artist=The artist,comment=Played on my radio:test.mp3
```

In particular, this can be used to add metadata in playlists (which can contain
files beginning with `annotate:`), to specify the usual information such as
artist and title (although those are generally already present in files), but
also internal information such as cue in and cue out time.

 More powerful, the `process` protocol allows to launch any command in order to
process files. The syntax is

```
process:<ext>,<cmd>:uri
```

where `<ext>` is the extension of the produced file, `<cmd>` is the command to
launch and `uri` is the uri of a file. In `<cmd>`, `$(input)` will be replaced
by the input file and `$(output)` by the output file (a temporary file whose
extension is `<ext>`. For instance, we can convert a file `test.mp3` in stereo
wav (even if the input file is mono) by:

```{.liquidsoap include="liq/process1.liq" from=1 to=-1}
```

When playing it, Liquidsoap will first download `test.mp3` into some place (say
`/tmp/temp.mp3`) and then execute

```
ffmpeg -y -i /tmp/temp.mp3 -ac 2 /tmp/temp.wav
```

in order to convert it to stereo wav, and then play the resulting temporary file
`/tmp/temp.wav`. The protocol `process` also accepts files of the form

```
process:<ext>,<cmd>
```

in which case only `$(output)` will be replaced in the command. For instance,
the implementation of text-to-speech in Liquidsoap essentially amounts to doing

```{.liquidsoap include="liq/process2.liq" from=1 to=-2}
```

which will run

```
echo 'Hello world!' | text2wave > /tmp/temp.wav
```

and play the resulting file.

#### Registering new protocols

One of the most powerful features of Liquidsoap is that it gives you the ability
of registering your own protocols. For instance, suppose that we have a program
`find_by_artist` which takes as argument the name of an artist and prints a
lists of music files from this artist. Typically, this would be achieved by
looking into a database of all your music files. For instance,

```
find_by_artist Halliday
```

will print

```
/data/mp3/allumer_le_feu.mp3
/data/mp3/l_envie.mp3
/data/mp3/que_je_t_aime.mp3
```

We are going to define a new protocol named `artist` so that, when playing a
file such as `artist:Halliday`, Liquidsoap will run the above command in order
to find a song. This can be done by using the `add_protocol` operator: its first
mandatory argument is the name of the protocol (here, `artist`) and the second
one is a function which takes as arguments

- a function `rlog` to log the resolution process (you can use it to print
  whatever is useful for you to debug resolution problems),
- a duration `maxtime` in seconds which the resolution should not exceed (you
  should be careful about it when querying distant servers which might take a
  long time for instance),
- the request,

and returns a list of file names (which might use any protocol again)
corresponding to the request (Liquidsoap will play one of them). In our example,
we implement the protocol as

```{.liquidsoap include="liq/add_protocol2.liq" from=1 to=-3}
```

We use the `add_protocol` to register our protocol `artist`, where the function
`artist_protocol`, which returns the list of files corresponding to a request,
simply returns the list of all the files printed by the command
`find_by_artist`. The `doc` parameter is free form documentation for the
protocol and the `syntax` parameter provides an illustration of a typical
request using this protocol (both are only for documentation purposes). Once
this defined, we can finally play songs of any artist:

```liquidsoap
s = single("artist:Haliday")
```

and, of course, an uri such as `artist:Haliday` could also be used in a playlist
or pushed in a request queue.

<!--
TODO: some other useful predefined protocols:

- s3
- annotate (detailed below)
- There is a [list of
protocols](https://www.liquidsoap.info/doc-dev/protocols.html)
-->

### Soundcard inputs

In order to input sound from a soundcard you should use functions such as
`input.alsa` or `input.pulseaudio` or `input.portaudio` depending on the library
you want to use for this: the first one is a little more efficient, because
closer to the hardware, and the second is more portable and widespread. For
instance, you can hear your voice with

```{.liquidsoap include="liq/mic.liq" from=1}
```

Basically, this scripts plays the stream generated by `input.alsa`. However, we
have to use the `buffer` operator in order to bufferize the stream coming from
the soundcard and deal with with synchronization issues between the input and
the output, as detailed in [there](#sec:clocks-ex).

If you want to use a particular device, you should use the parameter `device` of
`input.alsa`, which takes as argument a string of the form `hw:X,Y` where `X` is
the card number and `Y` is the device number. The list of all devices available
on your computer can be obtained with the command

```
aplay -l
```

On my computer this returns

```
card 0: PCH [HDA Intel PCH], device 0: ALC3246 Analog [ALC3246 Analog]
  Subdevices: 0/1
  Subdevice #0: subdevice #0
card 0: PCH [HDA Intel PCH], device 3: HDMI 0 [HDMI 0]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
```

so that if I want to input from HDMI, I should use `hw:0,3` as `device`
parameter.

By default, the ALSA operators have an internal buffer in order to be able to
cope with small delays induced by the soundcard and the computer. However, you
can set the `bufferize` parameter to `false` in order to avoid that in order to
reduce latencies. For instance, if you are lucky, you can hear your voice
almost in realtime, with some flanger effect added just for fun:

```{.liquidsoap include="liq/alsa-realtime.liq" from=1}
```

Beware that by reducing the buffers, you are likely to hear audio glitches due
to the fact that blank is inserted when audio data is not ready soon enough. In
this case, you should also see the following in the logs

```
Underrun! You may minimize them by increasing the buffer size.
```

which indicates that you should buffer in order to avoid defects in the audio.

### Icecast inputs with harbor {#sec:input.harbor}

Many programs are able to stream to an Icecast server, and we can use those as
an input for Liquidsoap scripts with the `input.harbor` operator. This operator
instructs Liquidsoap to run an Icecast-compatible server, called
_harbor_\index{harbor}. Clients can then connect to it, as they would do on any
Icecast server, and the stream they send there is then available as a source in
your script. This can be useful to relay a live stream without polling the
Icecast server for it, or if you have punctual distant interventions from live
speakers or DJs (for instance the [Mixxx](https://mixxx.org/) software can be
used to easily make mixes from home). A typical setup would be

```{.liquidsoap include="liq/input.harbor.liq" from=1}
```

In this example, we use the `playlist` source by default, but we give priority
to the `live` source, which is a harbor input, available only when some client
connects to it. Apart from the parameters specifying the port and the password
to use when connecting, the unlabeled argument specifies the _mountpoint_: this
should be specified by the client when connecting, which means that a same
harbor server can simultaneously relay multiple sources, as long as they use
different mountpoints.

In order to test the above script, you can use your favorite tool to stream to
Icecast. Ours obviously being Liquidsoap, you can run the script

```{.liquidsoap include="liq/input.harbor-client.liq" from=1}
```

which will stream connect to the harbor Icecast server and stream our music
library in mp3 format.


#### Security

Since harbor exposes a server to the internet, you should be serious about
security and think thoroughly about who should be having access to this
server. The fact that the server is programmed in OCaml makes it quite unlikely
that an exploit such as a buffer overflow is possible, but one never knows.

First the list of IPs which are allowed to connect to harbor can be changed with
the following setting:

```liquidsoap
set("harbor.bind_addrs", ["0.0.0.0"])
```

It takes as argument a list of allowed IPs, the default one 0.0.0.0 meaning that
every IP is allowed.

In practice, it is often quite difficult to know in advance the IPs of all the
clients, so that the main security is given by the password which is passed as
argument of `input.harbor`: please chose it wisely, and avoid at any means the
default password `"hackme"`. Even with a strong password, the security is not
very good: if some of the clients leaks the password or you want to revoke some
a client, you have to change it for every client which is not convenient. For
this reason, the authentication can also be done through a function, which is
passed as the `auth` argument of `input.harbor` and is of type `(string, string)
-> bool`: it takes as argument the username and the password of a client trying
to log in and returns whether it should be allowed or not. Typically, you would
like to call an external script, say `harbor-auth`, which will take the username
and password as argument and print "`allowed`" if the user is allowed (such a
command would usually look into a database to see whether the credentials match,
and perhaps do additional checks such as ensuring that the user has the right to
connect at the given time).

```{.liquidsoap include="liq/input.harbor-auth.liq" from=1}
```

Here, our function `auth` begins by executing the script `harbor-auth` with the
username and password as argument. Note that we use `string.quote` to escape
shell special characters, so that the user cannot introduce shell commands in
his username for instance... The `process.read.lines` function returns the list
of lines returned by our script and our function returns `true` or `false`
depending on whether this first line is "`allowed`" or not. In this way you
could easily query an external database of allowed users.

Finally, the clients should be able to determine that they are really connected
with your server and not some hacker's one. The best way to achieve that is to
use SSL certificates, which can be handled with the `input.harbor.ssl` variant
of the harbor source (it is present only if Liquidsoap has been compiled with
SSL support). The certificate can be specified with the setting
`harbor.ssl.certificate` (the setting `harbor.ssl.private_key` can also be used
to specify the private key and `harbor.ssl.password` the password to unlock the
private key). Obtaining a proper SSL certificate can be tricky. You may want to
start with a self-signed certificate first, which you can for instance obtain
from [Let's Encrypt](https://letsencrypt.org/). Alternatively, a self-signed
certificate for local testing you can use the following one-liner:

```
openssl req -x509 -newkey rsa:4096 -sha256 -nodes -keyout server.key -out server.crt -subj "/CN=localhost" -days 3650
```

### External inputs

In case you are still not satisfied (for instance, if you have very specific
needs or are the proud owner of hardware which is not widely supported), it is
possible to use any program as an input, as long as this program echoes audio on
its standard output either in wav or in raw audio format, with the operators
`input.external.wav` and `input.external.rawaudio`. Here, "raw audio" data
consists in interleaved samples encoded as signed 16 bits little-endian integers
(the use of the wav format is preferable to avoid confusions about the encoding
format). For instance, we can play a sine wave which is generated by the program
`ffmpeg` with

```{.liquidsoap include="liq/input.external.wav.liq" from=1 to=-1}
```

or with

```{.liquidsoap include="liq/input.external.rawaudio.liq" from=1 to=-1}
```

The argument `cmd` is the program which is going to be executed: here, we use
`ffmpeg` , which is instructed to generate a sine at 440 Hz (`-i
'sine=frequency=440'`) in stereo (`-ac 2`), encode it in wav (`-f wav`) or raw
format (`-f s16le`), and output it on the standard output (`-`).

#### Jack input

If the other program has support for it, it is possible to use
Jack\index{Jack} with the `input.jack` operator. This library is dedicated to
the communication of audio data between programs and greater stability and
precision is expected than with the above method. We do not detail it here,
because it involves some configuration (in particular, a dedicated Jack server
should be running) which is not specific to Liquidsoap.

#### GStreamer input

Finally, another very general possibility for input is to use the
`input.gstreamer.audio` operator in order to use the GStreamer\index{GStreamer}
library to generate audio. The generation itself is described through a
_pipeline_ which consists in a sequence of GStreamer operators separated by
"`!`": a pipeline "`a ! b`" means that the output of operator "`a`" should be
fed to operator "`b`". We refer the reader to the documentation of the library
for more information about it. In Liquidsoap, the pipeline can be passed in the
argument labeled `pipeline`, as expected. For instance, we can generate a sine
wave (again) with

```{.liquidsoap include="liq/input.gstreamer.liq" from=1 to=-1}
```

where we use the operator `audiotestsrc` to generate a sine, which we pipe to
the `audioamplify` operator to change its volume. Similarly, we can play the
file `test.mp3` with

```{.liquidsoap include="liq/input.gstreamer2.liq" from=1 to=-1}
```

In practice, no one would use the above example as is, because Liquidsoap
already has builtin support for using GStreamer to decode files...

Scheduling
----------

Now that we have a wide panel of sources, we need to combine them.

### Fallback {#sec:fallback}

The first way of combining sources is through the `fallback` operator, which
takes as argument a list of sources, and plays the first one which is available,
i.e. can produce some stream. We have already seen examples of this with request
queues ([here](#sec:request.queue)) such as

```liquidsoap
radio = fallback([queue, playlist])
```

Here, we want to play a song from the request queue when there is one, otherwise
we play songs from the playlist. By default, if we are playing a song from the
playlist and there is a new song in the queue, the operator will wait for the
current playlist song to finish before playing the one from the queue. This
behavior can be changed by setting the `track_sensitive` parameter to `false`,
in which case the song from the queue will be immediately played:

```liquidsoap
radio = fallback(track_sensitive=false, [queue, playlist])
```

Typically, you would use this to switch to a live show when available

```{.liquidsoap include="liq/input.harbor.liq" from=1 to=-1}
```

or to feature live interventions when someone is speaking on the microphone

```{.liquidsoap include="liq/blank.strip.liq" from=1 to=-1}
```

In this last example, we are using the operator `blank.strip` to make the source
`mic` unavailable when there are at least 2 seconds of silence (the duration is
controlled by the `max_blank` argument, and the `threshold` argument indicates
that we consider anything below -20 dB as silence): in this case, the `fallback`
operator will default to the `music` playlist until someone is speaking again.

In order to make a source `s` always available, it is quite common to stream
blank when the source is not available, i.e. re-define the source

```{.liquidsoap include="liq/fallible3.liq" from=1 to=-1}
```

with a fallback on blank. Since this is quite common in scripts, the function
`mksafe` is defined in the standard library as a shorthand, and the above is
equivalent to writing

```liquidsoap
s = mksafe(s)
```

### Switching and time predicates

Another way of selecting between sources is the `switch` operator which takes as
argument a list, whose elements are pairs consisting of a predicate and a
source. Here, each _predicate_ is function taking no argument an returning a
boolean (it is of type `() -> bool`) indicating whether the corresponding source
should be played or not. The `switch` operator will then select the first source
whose predicate returns `true`. For instance, supposing that we have two
different playlists for night and day, we could alternate between those
depending on the hour with

```{.liquidsoap include="liq/switch.liq" from=3 to=-1}
```

Here also, the `track_sensitive` parameter controls whether a change of source
only occurs at track boundaries (when `true`, which is the default) or as soon
as possible.

If you want to make sure that there is always something to play, the condition
of the last source should always be true, i.e. you can use `{true}`. For
instance,

```{.liquidsoap include="liq/switch2.liq" from=4 to=-1}
```

will have two special programs on morning and evening, and will default to the
`music` playlist at other times. We thus obtain the same behavior as if we had
used a `fallback` operator:

```{.liquidsoap include="liq/switch2-fallback.liq" from=4 to=-1}
```

#### Time predicates

In the above examples `{0h-7h}` is a _time predicate_: it is something which is
`true` or `false` depending on the current time. Some other examples of time
predicates are

-------------   -------------------------------------
`{11h15-13h}`   between 11h15 and 13h
`{12h}`         between 12h00 and 12h59
`{12h00}`       at 12h00
`{00m}`         on the first minute of every hour
`{00m-09m}`     on the first 10 minutes of every hour
`{2w}`          on Tuesday
`{6w-7w}`       on weekends
-------------   -------------------------------------

Above, `w` stands for weekday: 1 is Monday, 2 is Tuesday, and so on. Sunday is
both 0 and 7.

#### Other predicates

We could also use this operator to manually switch between sources. As an
illustration, suppose that we have two radio streams named `radio1` and `radio2`
then we could use a script such as

```{.liquidsoap include="liq/switch3.liq" from=6 to=6}
```

where the predicate `p` determines when `radio1` should be played. For instance,
if we want to play it when a file `select-radio` contains "`1`", we could define
it as

```{.liquidsoap include="liq/switch3.liq" from=3 to=3}
```

Another way to achieve this could be use an "interactive boolean", as detailed
in [there](#sec:telnet), and defined instead

```{.liquidsoap include="liq/switch3.liq" from=4 to=5}
```

The interactive boolean is a sort of reference whose value can be changed over
the telnet by issuing commands such as "`var.set r1 = true`", which sets the
value of the boolean named `r1` to `true`. Therefore, we can switch to radio 1
by typing the command

```
echo "var.set r1 = true" | nc localhost 1234
```

and back to radio 2 with

```
echo "var.set r1 = false" | nc localhost 1234
```

(or directly connecting to the telnet server and issuing the commands).

### Adding

Instead of switching between two sources, we can play them together with the
`add` operator, which takes a list of sources whose sound are to be added. For
instance, if we want to make a radio consisting of a microphone input together
with background music (which is often called a "bed"), we can define

```{.liquidsoap include="liq/add.liq" from=3 to=-1}
```

This will play the two sources `mic` and `bed` at equal volume. By default, the
volume of the output is divided by 2 (because there are 2 sources) in order not
increase the loudness too much. If you want to keep the original volume of the
sources, you should set the `normalize` parameter to `false`:

```{.liquidsoap include="liq/add2.liq" from=3 to=-1}
```

but beware that this might result into some clipping if the two sources are
loud, which is never nice to hear. The operator also offers the possibility of
weighting the sources: if we want to hear the microphone twice as loud as the
bed, we should give the microphone twice the weight of the bed. The weight of
each source can be specified in a list passed in the `weights` arguments. For
instance,

```{.liquidsoap include="liq/add3.liq" from=3 to=-1}
```

assigns the weight `2.` to `mic` and `1.` to `bed`. This is equivalent to
amplifying each of the sources with the corresponding factor, i.e.

```{.liquidsoap include="liq/add4.liq" from=3 to=-1}
```

but more efficient and natural.

As a side note, the operator `add` only adds the sources which are ready. This
means that if `mic` is taken from an harbor input such as

```{.liquidsoap include="liq/add.liq" from=1 to=1}
```

and the client did not connect or was disconnected, we will hear only the bed,
as expected.

### Sequencing

TODO: mention the `sequence` operator..............

### Jingles and ads

Jingles are short announcements, generally indicating the name of the radio or
the current show. They are quite important in order for the listener to remember
the brand of your radio and create some familiarity with the radio (the music
changes but the jingles generally remain the same). Technically, jingles are not
different from any other music source, but we give here the usual ways of
inserting those, presenting tricks which might be useful in other situations too
(in particular, ads follow basically the same techniques). We suppose here that
we have a source `music` which plays our music and a source `jingles` which
plays jingles: typically, it will be defined as

```{.liquidsoap include="liq/jingles-add.liq" from=1 to=1}
```

where `jingles` is a playlist containing all our jingles.

#### Playing only one track with `switch`

Let us begin with a quite common but tricky feature. Suppose that we want to
play a jingle at the beginning of each hour, without interrupting the current
track. One would typically write a script such as

```{.liquidsoap include="liq/jingles-once.liq" from=3 to=-1}
```

which states that when the current minute of the time is "00", we should play
the `jingles` source. But this is not really good: if a track from the music
source starts at 11h58 and ends at 12h01 then no ad will be played around
noon. In order to accommodate for this, we are tempted to widen the time
predicate and replace the second line with

```liquidsoap
    ({00m-15m}, jingles),
```

Well, this is not good either: if a track of the music source ends at 12h01, we
now hear a jingle as expected, but we actually continuously hear jingles for 14
minutes instead of hearing only one. In order to fix this, we are tempted to use
the `once` operator and change the line to

```liquidsoap
    ({00m-15m}, once(jingles)),
```

This is not good either: `once(jingles)` plays only one track from `jingles`,
but during the whole execution of the script. This means that our script will
only work as expected on the first hour, where we will correctly hear one
jingle, but on the following hours we will hear no jingle because one has
already been played.

The right solution, consist in using the `predicate.once` function: it takes a
predicate `p` as argument, and returns a predicate which is true only once each
time `p` is continuously true. In case it helps, we have illustrated in the
following figure an example of a predicate `p` over time (below) and the
resulting predicate `predicate.once(p)` over time (above):

![predicate.once](fig/predicate.once)\

This means that `predicate.once({12h00-12h15})` is a predicate which is true
once between 12h00 and 12h15. This is exactly what we were looking for, and the
script we were looking for is

```{.liquidsoap include="liq/jingles-once2.liq" from=3 to=-1}
```

As a variant, if we wanted to play a jingle every half hour, we could replace
the second line by

```liquidsoap
    ({00m-15m or 30m-45m}, once(jingles)),
```

As another variant, if we wanted to play 3 jingles, we could write

```liquidsoap
    (predicate.at_most(3, {00m-15m}), jingles),
```

where `predicate.at_most` is similar to `predicate.once`, but is true a given
number of times instead of only once (its it pointless to play 3 jingles in a
row, but this can be quite useful for ads for instance).

If we want to add the jingle on top of the currently playing music, we can use
the function `available(p, s)` which takes as arguments a predicate `p` and a
source `s` and makes the source available only when the predicate is
satisfied. We can then add the music with the jingles source made available once
every half hour as follows:

```{.liquidsoap include="liq/jingles-available.liq" from=3 to=-1}
```

#### Delaying tracks

Another approach consists in using the `delay` function which prevents a source
from being available before some time. For instance, we can play a jingle
roughly every 30 minutes with

```{.liquidsoap include="liq/jingles-delay.liq" from=3 to=-1}
```

The function `delay` above enforces that, after playing a track, the source will
not be available again before 1800 seconds (which is 30 minutes). Therefore
every time the current music track ends and more than 30 minutes has passed
since the last jingle, a new one will be inserted. As a variant, we can add the
jingle on top of the currently playing music with

```{.liquidsoap include="liq/jingles-delay2.liq" from=3 to=-1}
```

#### Rotating tracks

How often we should play jingles, instead of being based on time, can be based
on tracks. The `rotate` operator allows implementing such behaviors by
specifying that we want to play a track of such source every n tracks of such
other source. This function takes a list of sources and a list of weights
associated to each source (in the argument labeled `weight`), and selects tracks
from the sources according to the weights. For instance, in the following script

```{.liquidsoap include="liq/jingles-rotate.liq" from=3 to=-1}
```

we play `jingles` with weight `1` and `music` with weight `4`: this means that
we are going to play one jingle, then four music tracks, then one jingle, then
four music tracks, and so on. If you want something less regular, the `random`
operator can be used instead of `rotate`:


```{.liquidsoap include="liq/jingles-random.liq" from=3 to=-1}
```

It is basically a randomized version of the previous source, which will randomly
chose tracks from `jingles` and `music`, the probability of choosing a track
from the later being four times the probability of choosing a track from the
former.

The `rotate` and `random` operators can also be used to vary the contents of a
source. For instance, if we wanted our `jingles` sources to play alternatively a
jingle, a commercial and an announcement for a show, we could have defined

```{.liquidsoap include="liq/jingles-rotate2.liq" from=1 to=-1}
```

#### Signaling

As a more advanced use of predicate, we would like to introduce the
`predicate.signal` function which creates a particular predicate which is false
most of the time, unless some other part of the program sends a "signal", in
which case the predicate becomes true once and then false again (until the next
signal). Concretely, we can use this function to create a predicate `p` by

```liquidsoap
p = predicate.signal()
```

The predicate `p` is false by default, in order to make it true we can send a
signal by calling its method `signal`, i.e. writing `p.signal()`. For instance,
in the script

```{.liquidsoap include="liq/jingles-signal.liq" from=3 to=-1}
```

we use `predicate.signal` to create a predicate `p` which controls playing
jingles (if there is no jingle to play we default to the `music` source). We
then use `thread.run` to execute `p.signal()` every 20 minutes (or 1200
seconds). This means that every 20 minutes (or a bit more because we are waiting
for the current track of `music` to end), we will hear a jingle.

Of course, this is not the way one would typically regularly insert jingles, but
this can easily be modified to insert jingles by interacting with the
environment. For instance, we can register a command on the telnet server as
follows:

```{.liquidsoap include="liq/jingles-signal2.liq" from=6 to=-1}
```

The function `cmd`, when called with some argument, will run `p.signal()` and
return a string indicating that the jingle has been inserted. We then use the
`server.register` function to instruct Liquidsoap that the function `cmd` should
be called when a user runs the command `insert_jingle` on the telnet
server. This means that if you connect to the telnet server and type
`insert_jingle`, a jingle will be inserted after next track, which could be
quite useful if you are designing some sort of a graphical interface for your
radio.

#### Inserting jingles on metadata

We will also see in [next section](#sec:tracks) that the insertion of jingles
can also conveniently be triggered by metadata in sources.

#### Inserting jingles in transitions

Yet another method for inserting transition consists in adding them in
transitions between tracks, this is detailed in [a later
section](#sec:transitions).

Tracks and metadata {#sec:tracks}
-------------------

Liquidsoap has a notion of _track_ in stream, which is generally used to mark
the boundary between two successive songs. We have seen that many functions to
control the stream (`fallback`, `switch`, etc.) have the ability to detect
tracks and only change stream when a track is over in order not to abruptly
interrupt a playing song (this behavior can be altered by setting the
`track_sensitive` parameter to `false`).

To every track is associated metadata, which are information concerning the song
which is going to be played. In Liquidsoap, metadata can actually be present at
any time, and don't have to correspond to a track boundary (we can have metadata
in the middle of a song) although this is generally the case. We have seen that
metadata is generally coded as an association list, as detailed in
[there](#sec:association-list): this is a list consisting of pairs of strings,
whose type is thus `[string * string]`. Typically, the metadata `m` for a track
will look like

```{.liquidsoap include="liq/metadata.liq" from=0 to=0}
```

which indicates that the artist is "Sinatra" and the title is "Fly me". Typical
metadata fields are: artist, title, album, genre, year and comment.

In order to retrieve the title in such a list, one should use the notation

```liquidsoap
m["title"]
```

which will return the value associated to the field `title` in the metadata `m`,
the empty string `""` being returned in the case where the metadata is not
present. Changing the value of some metadata is simply obtained by putting the
new metadata at the top, by using the function `list.append`. For instance, we
can define a metadata `m'` where the artist has been changed and the year has
been added by

```{.liquidsoap include="liq/metadata.liq" from=1 to=1}
```

Metadata are usually stored within files (for instance, mp3 files generally
contain metadata encoded in the ID3v2 format). Typical operators reading files,
such as `playlist`, automatically read those when opening a file. We recall that
it is also possible to add metadata to files in playlists using the annotate
protocol described above. For instance,

```
annotate:artist=The artist,comment=Played on my radio:test.mp3
```

Incidentally, the `prefix` parameter of the `playlist` operator can be used to
add a prefix to every file in the playlist. It can in particular be used to
annotate every file in order to add some metadata. For instance, if we want to
set the metadata `jingle` to `true` for every track in our playlist, we can
write something like

```{.liquidsoap include="liq/playlist-prefix.liq" from=1 to=-1}
```

### Handling tracks

Each source has a method `on_track` and a method `on_metadata` to execute a
function when a track boundary or metadata occur in the stream. In both cases,
it takes as argument a function of type `([string * string]) -> unit`: this
function itself will be called with the metadata as argument.

#### Logging tracks

We can use this to log every song which has gone on air:

```{.liquidsoap include="liq/log-songs.liq" from=1 to=-1}
```

We first define a function `log_song` which takes the metadata `m` as argument,
extracts the artist and the title, and appends those to the file
`/tmp/songs`. We then run the method `on_track` of our `music` source to
register this function to be called when there is a new track and that's it! By
the way, if you want a quick and effective logging of the metadata, we would
advise the use the `json_of` function, which will convert all the metadata at
once into a standardized textual representation called
[JSON](https://www.json.org/):

```{.liquidsoap include="liq/log-songs2.liq" from=1 to=3}
```

#### Adding jingles on metadata

The above functions can also be used in order to insert jingles (or ads) when
some metadata is present. For instance, we suppose that we have a music source
`s`, perhaps generated by a playlist: when a track has the metadata `jingle` set
to `true`, we want to play a jingle beforehand. One way to perform this is

```{.liquidsoap include="liq/jingles-metadata.liq" from=10}
```

It consists in creating a queue `q` and executing a function `insert_jingle`
when a track is present: this function will look whether the value of the
`jingle` metadata is `true`, and if this is the case it will insert a jingle
(the file `jingle.mp3`) into the queue, which will then be played by a usual
fallback mechanism. As an easy variant of the above script, we can read out the
last song which was played on air, by inserting in a queue a request to read it
using the `say` protocol:

```{.liquidsoap include="liq/jingles-metadata2.liq" from=5}
```

Another approach to insert jingles when the particular metadata is present could
consist in using the `predicate.signal` function detailed above to trigger
playing one track of a `jingles` playlist when the metadata is present:

```{.liquidsoap include="liq/jingles-metadata3.liq" from=10}
```

#### Prepending and appending tracks

The logic of the programs can be somewhat simplified by the use of the `prepend`
operator: this operator takes as argument a function which is called on every
track, with its metadata as source, and returns a source to be played before the
current track. For instance, we can insert a jingle when the metadata `jingle`
is set to `true` by:

```{.liquidsoap include="liq/jingles-prepend.liq" from=11}
```

The function `insert_jingle` looks at the metadata, and if present returns the
`jingles` source, containing all the jingles, of which one track will be
played. If the metadata is not present, we return `fail()` which is a source
which is never available: in this case, prepend will simply not insert any track
because none is ready. The function is then registered with the `prepend`
operator.

Of course, there is a dual operator `append` which allows appending a track for
every track: contrarily to `prepend`, it inserts the track after the currently
playing track. For instance, we can read the song which we have just played with

```{.liquidsoap include="liq/jingles-prepend2.liq" from=5}
```

### Rewriting metadata

If you want to systematically modify the metadata, you can use the
`map_metadata` function which will modify the metadata of a source: it takes as
argument a function and a source, and uses the function to systematically change
the metadata. The type of the function is

```
([string * string]) -> [string * string]
```

it takes the current metadata and returns the new metadata to be inserted. For
instance, we can add the year in the title and a comment into the metadata of
our source `s` with

```{.liquidsoap include="liq/map_metadata.liq" from=2 to=-1}
```

Whenever a metadata passes on the source `s`, the function `f` is executed with
it and returns the metadata to insert. Here, it states that we should set the
title to `"<title> (<year>)"` (where `<title>` is the title and `<year>` is the
year present in the original metadata) and that we should advertise about
Liquidsoap in the field `comment`.


### Removing tracks and metadata

In order to remove the tracks of a source, the `merge_track` operator can be
used: it takes a source `s` as argument and returns the same source with the
track boundaries removed.

Similarly, `drop_metadata` removes all metadata from a source. This can be
useful if you want to "clean up" all the metadata before inserting your own, as
indicated below.

### Inserting tracks and metadata

If you want to insert tracks or metadata at any point in a source, you can use
the `insert_metadata`: this operator takes a source as argument and returns the
same source with a new method `insert_metadata` whose type is

```
(?new_track : bool, [string * string]) -> unit
```

It takes an argument labeled `new_track` to indicate if some track should be
inserted along with the metadata (by default, not) and the metadata, and inserts
the metadata in the stream. For instance, suppose that we have a source `s` and
we want to set the title and artist metadata to "Liquidsoap" every minute. This
can be achieved by

```{.liquidsoap include="liq/insert_metadata.liq" from=2 to=-1}
```

Here, we add the ability to insert metadata in the source `s` with the operator
`insert_metadata`, and we then use `thread.run` to regularly call a function
which will insert metadata by calling `s.insert_metadata`.

Similarly, we can add a telnet command to change the title metadata by

```{.liquidsoap include="liq/insert_metadata-title.liq" from=3 to=-1}
```

Again, we suppose given a source `s`. We begin by defining a function `cmd`
which takes the title as argument, inserts it into the stream of `s`, and
returns a message saying that the title was inserted. We then register this
command as `set_metadata` on the telnet server (see [there](#sec:telnet) for
details): when we enter the command

```
set_title New title
```

on the telnet, the title will be set to "New title". In fact, the standard
library offers a generic function in order to do this and not have to program
this by yourself: the function `server.insert_metadata` takes an identifier `id`
and a source as argument and registers a command `id.insert` on the telnet which
can be used to insert any metadata. A typical script will contain

```{.liquidsoap include="liq/server.insert_metadata.liq" from=3 to=-1}
```

and we can then set the title and the artist by running the telnet command

```
src.insert title="New title",artist="Liquidsoap"
```

(the argument of the command is of the form `key1=val1,key2=val2,key3=val3,...`
and allows specifying the key / value pairs for the metadata).

<!--
### ICY metadata

*ICY metadata* is the name for the mechanism used to update metadata in
icecast's source streams. The techniques is primarily intended for data formats
that do not support in-stream metadata, such as mp3 or AAC. However, it appears
that icecast also supports ICY metadata update for ogg/vorbis streams.

When using the ICY metadata update mechanism, new metadata are submitted
separately from the stream's data, via a http GET request. The format of the
request depends on the protocol you are using (ICY for shoutcast and icecast 1
or HTTP for icecast 2).

Starting with 1.0, you can do several interesting things with icy metadata
updates in liquidsoap. We list some of those here.

You can enable or disable icy metadata update in `output.icecast` by setting the
`icy_metadata` parameter to either `"true"` or `"false"`. The default value is
`"guess"` and does the following:

- set `"true"` for: mp3, aac, aac+, wav
- set `"false"` for any format using the ogg container

You may, for instance, enable icy metadata update for ogg/vorbis streams.

The function `icy.update_metadata` implements a manual metadata update using the
ICY mechanism. It can be used independently from the `icy_metadata` parameter
described above, provided icecast supports ICY metadata for the intended stream.

For instance the following script registers a telnet command name
`metadata.update` that can be used to manually update metadata:

```liquidsoap
def icy_update(v) =
  # Parse the argument
  l = string.split(separator=",",v)
  def split(l,v) =
    v = string.split(separator="=",v)
    if list.length(v) >= 2 then
      list.append(l,[(list.nth(v,0,default=""),list.nth(v,1,default=""))])
    else
      l
    end
  end
  meta = list.fold(split,[],l)

  # Update metadata
  icy.update_metadata(mount="/mystream",password="hackme",
                      host="myserver.net",meta)
  "Done !"
end

server.register("update",namespace="metadata",
                 description="Update metadata",
                 usage="update title=foo,album=bar,..",
                 icy_update)
```

As usual, `liquidsoap -h icy.update_metadata` lists all the arguments
of the function.
-->

### Skipping tracks

Every source has a method `skip` which allows skipping the current track and go
to the next one. For instance, if our main source is `s`, we can hear the first
5 seconds of each track of `s` with

```{.liquidsoap include="liq/source.skip.liq" from=2}
```

We could also easily use this to register a telnet command but this done by
default with the `playlist` operator: you can always use the `skip` telnet
command (or `id.skip` if an identifier `id` was specified for the source) to
skip the current song. For instance, with the script

```{.liquidsoap include="liq/source.skip2.liq" from=1}
```

running the telnet command `music.skip` will end the current track and go to the
next one. As another example, let us register skip as an http service: the script

```{.liquidsoap include="liq/source.skip3.liq" from=2}
```

makes it so that whenever we connect to the url `http://localhost:8080/skip` the
current song on the source `s` is abruptly ended: this is part of the
interaction you would typically have when designing a web interface for your
radio. Interaction through telnet and harbor http is handled in
[there](#sec:interaction), so that we do not further detail this example here.

\TODO{seeking}

### End of tracks

TODO: `source.on_end`

example, say the current song 10 seconds before the end

say that this is used to implement fade outs

Transitions {#sec:transitions}
-----------

So far, we have seen that we can easily play several music files sequentially
(for instance with the `playlist` operator) or switch between two sources (using
the `fallback` or `switch` operators). However, the resulting transitions
between two tracks are quite abrupt: one track ends and the other starts. We
often want crossfading transitions between tracks, which means that the volume
of the first track should be progressively lowered and the one of the second
progressively increased in such a way that we hear the two during the
transition:

![Transition](fig/transition)\

Note that, as figured in the graph above, we don't necessarily want the duration
of the transition to be the same for all tracks: for instance, the transition
should be shorter (or there should even be no transition) for tracks starting or
ending abruptly.

Liquidsoap supports both

- transitions between two distinct sources (for instance, when changing the
  source selected by a `switch`), and
- transitions between consecutive tracks of the same source.

The latter are more tricky to handle, since they involve a fast forward
computation of the end of a track before feeding it to the transition function:
such a thing is only possible when only one operator is using the source,
otherwise we will run into synchronization issues.

### Cue points

Before performing transitions, we should first ensure that our tracks begin and
end at the right time: some songs features long introductions or long endings,
that we would like not to play on a radio (think of a Pink Floyd song). In order
to do so, we would rather avoid directly editing the music files, and simply add
metadata indicating the time at which we should begin and end playing the files:
these are commonly referred to as the _cue in_ and the _cue out_ points.

The `cue_cut` operator takes a source and cuts each track according to the cue
points which are stored in the metadata: by default, the metadata `liq_cue_in`
and `liq_cue_out` are used for cue in and cue out points (the name of the
metadata can be changed with the `cue_in_metadata` and `cue_out_metadata`
parameters of `cue_cut`), and are supposed to be specified in seconds relative
to the beginning of the track.

For instance, in the following example, we use the `prefix` argument of
`playlist` to set `liq_cue_in` to `30` and `liq_cue_out` to `40.5` for every
track of the playlist:


```{.liquidsoap include="liq/cue_cut.liq" from=2}
```

We will thus play every song of the playlist for 10.5 seconds, starting at
second 30. In practice, the metadata for cue points would either be hardcoded in
the files or added for each file with `annotate` in the playlist. In a more
elaborate setup, a `request.dynamic` setup would typically also use `annotate`
in order to indicate the cue points, which would be fetched by your own
scheduling back-end (for instance, the cue points could be stored in a database
containing all the songs).

### Fading

In order to have smoother transitions, a first way to proceed is to
progressively increase the volume from 0 (the minimum) to 1 (the maximum) at the
beginning of tracks and progressively decrease the volume from 1 to 0 at the end
of tracks: these operations are respectively called _fading in_ and _fading out_
and their effect on the volume can be pictured as follows:

![Fading in and out](fig/fade-in-out)\

The operators `fade.in` and `fade.out` fade respectively in and out every track
of the source given as argument. The `duration` parameter controls the duration
in seconds of the fade: this corresponds to the length of the ramp on the above
figures, by default it takes 3 seconds to entirely change the volume. The
duration can also be changed by using setting the metadata `liq_fade_in` (the
name can be changed by with the `override_duration` parameter of the
functions). Finally, the parameter `type` controls the shape of the fade: it can
respectively be `"lin"`, `"sin"`, `"log"` and `"exp"` which will respectively
change the shape of the fade as follows:

![Fading shapes](fig/fade-shapes)\

The default shape is linear (it is the simplest), but the sine fade tends to be
the smoother for the ear. For instance, the script

```{.liquidsoap include="liq/fade.liq" from=2 to=-1}
```

will add a sinusoidal fade in of 4 seconds and a linear fade out of 3 seconds to
every track of the source `s`.

### Transitions between different sources

The operators which allow switching between different sources (`switch`,
`fallback`, `rotate` and `random`) allow specifying the transitions to be
applied when switching from one source to the other. A _transition_ is described
by a function taking two sources as arguments and returning a new source: the
first argument is the source which is about to be left, the second argument is
the newly selected source, and the returned source is the result of their
combination. The default transition is the function

```
fun (a, b) -> b
```

which simply discards the stream from the old source and returns the one of the
new one. In practice, the first argument is often irrelevant because Liquidsoap
cannot predict accurately when the next switch will occur.

The switching operators all take an argument `transition_length` which controls
the length of the transition in seconds, i.e. how long the two sources `a` and
`b` will overlap, the result of the overlap being computed by the transition
function. They also take a list `transitions`: the nth element of this list is
the transition function that will be used when switching to the nth source.

In order to illustrate this, suppose that we have two sources: `live` which is a
live source available from time to time (for instance, a DJ connecting to an
`input.harbor` source) and `music` which is a local music source (for instance,
a playlist). In such a situation, we would define with a fallback which plays
the live source if available and defaults to the music source otherwise:

```liquidsoap
radio = fallback(track_sensitive=false, [live, music])
```

We want to enhance our setup and have transitions such that

- when we switch to the live source, we want to hear "And now the live show!"
  while the sound of the live source progressively fades in,
- when we switch back to the music source, we want to hear a jingle and then the
  music source.


```{.liquidsoap include="liq/fallback-transition.liq" from=4 to=-1}
```

TODO: say that we want `normalize=false` for add!

TODO: say that the duration of the transition should always be strictly greater than the fade duration


The switch-based operators (`switch`, `fallback`, `rotate` and `random`) support
transitions. For every child, you can specify a transition function computing
the output stream when moving from one child to another. This function is given
two `source` parameters: the child which is about to be left, and the new
selected child. The default transition is `fun (a,b) -> b`, it simply relays the
new selected child source.

Transitions have limited duration, defined by the `transition_length`
parameter. Transition duration can be overriden by passing a metadata. Default
field for it is `"liq_transition_length"` but it can also be set to a different
value via the `override` parameter.

Here are some possible transition functions:

```liquidsoap
# A simple (long) cross-fade
# Use metadata override to make sure transition is long enough.
def crossfade(a,b)
  def add_transition_length(_) =
    [("liq_transition_length","15.")]
  end

  transition =
    add(normalize=false,
          [ sequence([ blank(duration=5.),
                       fade.in(duration=10.,b) ]),
            fade.out(duration=10.,a) ])

  # Transition can have multiple tracks so only pass the metadata
  # once.
  map_first_track(map_metadata(add_transition_length),transition)
end

# Partially apply next to give it a jingle source.
# It will fade out the old source, then play the jingle.
# At the same time it fades in the new source.
# Use metadata override to make sure transition is long enough.
def next(j,a,b)
  # This assumes that the jingle is 6 seconds long
  def add_transition_length(_) =
    [("liq_transition_length","15.")]
  end

  transition =
    add(normalize=false,
	  [ sequence(merge=true,
	             [ blank(duration=3.),
	               fade.in(duration=6.,b) ]),
	    sequence([fade.out(duration=9.,a),
	              j,blank()]) ])

  map_first_track(map_metadata(add_transition_length),transition)
end

# A transition, which does a cross-fading from A to B
# No need to override duration as default value (5 seconds)
# is over crossade duration (3 seconds)
def transition(j,a,b)
  add(normalize=false,
	  [ fade.in(duration=3.,b),
	    fade.out(duration=3.,a) ])
end
```

Finally, we build a source which plays a playlist, and switches to the live show
as soon as it starts, using the `transition` function as a transition. At the
end of the live, the playlist comes back with a cross-fading.

```liquidsoap
fallback(track_sensitive=false,
	     transitions=[ crossfade, transition(jingle) ],
	     [ input.http("http://localhost:8000/live.ogg"),
	       playlist("playlist.pls") ])
```

mention the `transitions` parameter of `fallback`, e.g. for nice switching to
live

see also: <https://github.com/savonet/liquidsoap/issues/1541>

### Cross-based transitions

The `cross` operator allows arbitrary transitions between tracks of a same
source. Here is how to use it in order to get a cross-fade:

```liquidsoap
def crossfade(~start_next,~fade_in,~fade_out,s)
  fade.in = fade.in(duration=fade_in)
  fade.out = fade.out(duration=fade_out)
  fader = fun (_,_,_,_,a,b) -> add(normalize=false,[fade.in(b),fade.out(a)])
  cross(duration=start_next,fader,s)
end
my_source =
  crossfade(start_next=1.,fade_out=1.,fade_in=1.,my_source)
```

The `crossfade()` function is already in liquidsoap. Unless you need a custom
one, you should never have to copy the above example. It is implemented in the
scripting language, much like this example. You can find its code in
`utils.liq`.

The fade-in and fade-out parameters indicate the duraction of the fading
effects. The start-next parameters tells how much overlap there will be between
the two tracks. If you want a long cross-fading with a smaller overlap, you
should use a sequence to stick some blank section before the beginning of `b` in
`fader`.  The three parameters given here are only default values, and will be
overriden by values coming from the metadata tags `liq_fade_in`, `liq_fade_out`
and `liq_start_next`.

For an advanced crossfading function, you can see the [crossfade
documentation](crossfade.html)

```{.liquidsoap include="liq/crossfade.liq" from=1}
```


Signal processing
-----------------

### Amplification

TODO: `amplify` / amplify with metadata / replaygain

### Normalization

normalization, replaygain (the protocol)

LADSPA plugins

Good examples:

- <https://savonet-users.narkive.com/MiNy36h8/have-a-sort-of-fm-sound-with-liquidsoap>
- <https://www.mkpascal.net/2015/10/25/broadcast-audio-liquidsoap.html> and
  <https://github.com/mkpascal/mk_liquidsoap_processing>
- <https://github.com/JamesHarrison/conduit>
- <https://pzwiki.wdka.nl/mediadesign/Liquidsoap>
- <https://gist.github.com/130db/6001343>

### Blank

The various functions to remove blank

### Parameters

We can obtain parameters through telnet (explain how to save the values with
persistency + harbor server) / OSC

### Stereotool

TODO.......

### Jack

mention jack again

Outputs
-------

### Files

`output.file`, common encoding formats

It is sometimes useful (or even legally necessary) to keep a backup of an audio
stream. Storing all the stream in one file can be very impractical. In order to
save a file per hour in wav format, the following script can be used:

```
# A source to dump
# s = ...

# Dump the stream
file_name = '/archive/$(if $(title),"$(title)","Unknown archive")-%Y-%m-%d/%Y-%m-%d-%H_%M_%S.mp3'
output.file(%mp3,filename,s)
```

This will save your source into a `mp3` file with name specified by `file_name`.
In this example, we use [string interpolation](language.html) and time litterals to generate a different
file name each time new metadata are coming from `s`.


### Icecast

mention `output.harbor`

### HLS output

TODO: multiple qualities, we can convert to mono with `mean`

### Youtube

TODO: example of Youtube output, we should work out native ffmpeg youtube output

### Encode once, output multiple times

TODO: explain how to encode in mp3 and output both in a file and to Icecast without re-encoding

Testing and monitoring
----------------------

See above for logging tracks

### Blank detection

Use `on_blank` to detect blank...

Some telnet (e.g. know the current song for a source, etc.)


On GeekRadio, we play many files, some of which include bonus tracks, which
means that they end with a very long blank and then a little extra music. It's
annoying to get that on air. The `skip_blank` operator skips the
current track when a too long blank is detected, which avoids that. The typical
usage is simple:

```liquidsoap
# Wrap it with a blank skipper
source = skip_blank(source)
```

At [RadioPi](http://www.radiopi.org/) they have another problem: sometimes they
have technical problems, and while they think they are doing a live show,
they're making noise only in the studio, while only blank is on air; sometimes,
the staff has so much fun (or is it something else ?) doing live shows that they
leave at the end of the show without thinking to turn off the live, and the
listeners get some silence again. To avoid that problem we made the
`strip_blank` operators which hides the stream when it's too blank
(i.e. declare it as unavailable), which perfectly suits the typical setup used
for live shows:

```liquidsoap
interlude = single("/path/to/sorryfortheblank.ogg")
# After 5 sec of blank the microphone stream is ignored,
# which causes the stream to fallback to interlude.
# As soon as noise comes back to the microphone the stream comes
# back to the live -- thanks to track_sensitive=false.
stream = fallback(track_sensitive=false,
	              [ strip_blank(max_blank=5.,live) , interlude ])

# Put that stream to a local file
output.file(%vorbis, "/tmp/hop.ogg", stream)
```

If you don't get the difference between these two operators, you should learn
more about liquidsoap's notion of [source](sources.html).

Finally, if you need to do some custom action when there's too much blank, we
have `on_blank`:

```liquidsoap
def handler()
  system("/path/to/your/script to do whatever you want")
end
source = on_blank(handler,source)
```

### Metrics

Compute RMS and LUFS, conversion with `dB_of_lin` and conversely, `vumeter`, etc.

TODO: expose metrics with JSON on harbor

```{.liquidsoap include="liq/metrics-harbor.liq" from=1}
```

TODO: explain the variant where we store on a file regularly

```{.liquidsoap include="liq/metrics-file.liq" from=1}
```

TODO: expose metrics with prometeus

### Testing scripts

- log as much as possible and use priorities meaningfully
- mention `chopper`, which is useful to simulate track boundaries
- `sine` etc are of course useful to generate sound, also `metronome`
- tracks can be generated with the `synth:` protocol
  (`"synth:shape=sine,frequency=880,duration=1`", default values (shape is sine,
  freq is 440, duration is 1))
- `sleeper`
- what else?

Full example (already presented, we only want to show the first part here)...:

```{.liquidsoap include="liq/jingles-metadata.liq"}
```

It can also be useful to skip with `thread.run`

```{.liquidsoap include="liq/jingles-metadata2.liq"}
```

we can simulate a live source as in

```{.liquidsoap include="liq/fallback-transition.liq"}
```


- the `synth` protocol (already presented in "testing scripts" section)

Interacting with other programs {#sec:interaction}
-------------------------------

### Running external programs

`process.run`

### Telnet {#sec:telnet}

- add a skip command
- switch between sources

give an example of a python script (e.g. to skip)

### Harbor

### OSC

We should put the telnet and http here?

###  External decoders/encoders

TODO: many people want to use [stereotool](https://www.stereotool.com/), cf
https://github.com/savonet/liquidsoap/issues/885

### Webcast
