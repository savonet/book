Full workflow of a radio station {#chap:workflow}
================================

This chapter explains in details the main tools and techniques in order to setup
a webradio. It essentially follows [the introductory chapter](#chap:quickstart),
but gives much more details about techniques and parameters one can use to
achieve his goals.

Sound inputs
------------

### Playlists

A radio generally starts with a playlist, which is simply a file listing files
to be played. The `playlist`\index{playlist@\texttt{playlist}} operator does
that: it takes as a playlist argument and plays it. For instance, the script

```{.liquidsoap include="liq/playlist2.liq" from=1}
```

will play all the files listed in the `my_playlist` playlist. The operator also
accepts a directory as argument, in which case the playlist will consist of all
the file in the directory: the script

```{.liquidsoap include="liq/playlist.liq" from=1}
```

will play all the files in the `Music` directory. The format of the playlists
generally consist in listing files, with one file per line, such as

```
/data/mp3/file1.mp3
/data/mp3/file2.mp3
/data/mp3/file3.mp3
http://server/file.mp3
ftp://otherserver/file.mp3
```

but other more advanced playlist formats are also supported: pls, m3u, asx,
smil, xspf, rss podcasts, etc. Those are generally created by using dedicated
software.

By default, the files are played in a random order but this can be changed with
the `mode` parameter of `playlist` which can either be

- `"normal"`: play files in order,
- `"randomize"`: play files in a random order chosen for the whole playlist at
  each round (default mode),
- `"random"`: pick a random file each time in the playlist (there could thus be
  repetitions in files).
  
By default, the playlist is never reloaded, but this can be changed by using the
parameters `reload` and `reload_mode`, for instance:

- reload the playlist every hour (1 hour being 3600 seconds):
  
  ```liquidsoap
  s = playlist(reload=3600, reload_mode="seconds", "playlist")
  ```

- reload the playlist after each round (when the whole playlist has been played):

  ```liquidsoap
  s = playlist(reload=1, reload_mode="rounds", "playlist")
  ```
  
- reload the playlist whenever it changes (this requires Liquidsoap being
  compiled with support for the inotify library):

  ```liquidsoap
  s = playlist(reload_mode="watch", "playlist")
  ```

Another useful option is `check_next`, to specify a function which will
determine whether a file should be played or not in the playlist: this function
takes a request as argument and returns a boolean. For instance, we can ensure
that only the files whose name end in ".mp3" are played with

```{.liquidsoap include="liq/playlist-check.liq" from=1 to=-1}
```

The function `check` takes the request `r` given as argument, extracts its uri,
and then returns true or false depending on whether this uri ends with ".mp3" or
not. As another example, we can base our decision on the metadata of the file
as follows:


```{.liquidsoap include="liq/playlist-check2.liq" from=1 to=-1}
```

Here, we use the function `request.read_metadata` to force the reading of the
metadata for the request (this is not done by default at this point), obtain the
metadata with `request.metadata`, and declare that we should play a file only if
its genre is "Rock" (remember that the metadata are encoded as an association
list as explained in [there](#sec:association-list)).

If you only need to play one file, you can avoid creating a playlist with this
file only, by using the operator `single` which loops on one file. This operator
is also more efficient in the case the file is distant because it is downloaded
once for all:

```liquidsoap
s = single("http://server/file.mp3")
```

By the way, if you do not want to loop over and over the file, and only play it
once, you can use the operator `once` which takes a source as argument and plays
one song of this source (it becomes unavailable after that).

```liquidsoap
s = once(single("http://server/file.mp3"))
```

### Distant streams

The operators `playlist` or `single` make sure in advance that the file to be
played is available: in particular, they download distant files so that we are
sure that they are ready when we need them. Because of this, they are not
suitable in order to play continuous streams (which are very long, or even
infinite), because Liquidsoap would try to download them entirely before reading
them.

This is the reason why the `input.http` operator should be used in order to play
a stream:

```{.liquidsoap include="liq/input.http.liq" from=1 to=-1}
```

This operator works with streams such as those generated by Icecast, but also
with playlists containing streams. It will regularly pull data from the given
location, and therefore should be used for locations that are assumed to be
available most of the time. If not, it might generate unnecessary traffic and
pollute the logs: in this case, it is perhaps better to inverse the paradigm and
use the `input.harbor` operator described below, which allows the distant stream
to connect to Liquidsoap. If the stream is using secure http protocol (if the
uri starts with `https://...`), the operator `input.https` should be used
instead.

Streams in HLS format are quite different from the above (they consist of a
rolling playlist of short audio segments, see [there](#sec:HLS)) and are
therefore handled by a different operator, `input.hls`:

```{.liquidsoap include="liq/input.hls.liq" from=1 to=-1}
```

<!--
In this protocol the stream is segmented in small files and Liquidsoap will
regularly look for new segments (how often can be controlled by the `reload`
parameter).
-->

<!--
\TODO{polish this: we can use input.ffmpeg}
TODO: the format is optional and usually well detected, the list of supported formats can be obtained with `ffmpeg -formats`

```{.liquidsoap include="liq/input.ffmpeg-hls.liq"}
```
-->

### Interactive playlists {#sec:request.dynamic}

Instead of having a static playlist, you might want to use you own script to
generate the song which should be played next (e.g.Â you might fetch requests
from users from the web or a database, or you might have a neural network
deciding for you which song is the best to be played next). In this case you
should use `request.dynamic`, which takes as argument a function returning the
next song to be played. This function has type `() -> request('a)`, meaning that
it takes no argument and returns a request. For instance, suppose that we have a
script called `next-song`, which echoes the next song to be played on the
standard output. A degenerate example of such a script, using the shell, could
be

```{.bash include="liq/next-song"}
```

which always returns `test.mp3` as song to be played, but of course you could
use any program in any programming language as long as it outputs the file to be
played on the standard output. We can then query this script in order to play
song as follows:

```{.liquidsoap include="liq/request.dynamic.liq" from=1 to=-1}
```

Here, our `next` function executes the above script `next-song`, using the
function `get_process_lines` which returns the list of lines returns by the
script. We then take the first line with `list.hd` and return a request from
created from it using `request.create`. As a variant, suppose that the next song
to be played is present in a file named `song`. We can play it as follows:

```{.liquidsoap include="liq/request.dynamic2.liq" from=1 to=-1}
```

The `check` function now reads the contents of the file `song` and creates a
request from it. In the case were the file is empty there is no song to play,
and in this case we return the value `null` to indicate it. The `retry_delay`
parameter of `request.dynamic` indicates that, in this last case, we should wait
for 1 second before trying again. This example is not perfect: there is a chance
that a given song will be played multiple times if we don't update the file
`song` timely enough: we see a better way of achieving this kind of behavior in
next section.

### Request queues {#sec:request.queue}

In an interactive playlist, the operator asks for the next song. But in some
situations, instead of this passive way of proceeding (you are asked for songs),
you would rather have an active way of proceeding (you inform the operator of
new files when you have some). Typically, if you have a website where users can
request songs, you would like to be able to put the requested song in a playlist
at the moment the user requests it. This is precisely the role of the
`request.queue` operator, which maintains a list of songs to be played in a
queue (the songs are played in the order they are pushed). A typical setup
involving this operator would be the following:

```{.liquidsoap include="liq/request.queue.liq" from=1}
```

We have both a playlist and a queue, and the radio is defined by using the
`fallback` operator which tries to fetch the stream from the queue and if none
is available defaults to the playlist. The `track_sensitive=false` instructs
that we should play the stream from the queue as soon as it is available: by
default, `switch` will wait for the end of the current track before switching to
the queue.

#### Pushing songs in a queue

You might wonder then: how do we add new songs in the queue?  The role of the
first line is to instruct Liquidsoap to start a server, which is listening by
default on port 1234, on which commands can be sent; we refer the reader to
[this section](#sec:telnet) for details about this telnet server. The queue will
register a new command on this server so that if you connect to it and write
`queue.push` followed by an uri, it will be pushed into the queue. In practice
this can be done with commands such as

```
echo "queue.push test.mp3" | nc localhost 1234
```

which uses the standard unix tool `nc` to connect to the server on supposed to
be running on the local host on port 1234, and write the command `queue.push
test.mp3` on this server, to which it will react by adding the song "`test.mp3`"
on the queue.

If you have multiple queues in your script, you can specify their names by
specifying the `id` parameter of `request.queue`, which can be any string you
want, so that the command will be `id.push` (where `id` is replaced by the id
you specified) and you know in which queue you are pushing. For instance, in the
script

```{.liquidsoap include="liq/request.queues.liq" from=1}
```

the two queues are respectively called `q1` and `q2`, so that we can push a song
on the second queue by issuing the telnet command `q2.push file.mp3`.

It is also possible to push a request into the queue directly from Liquidsoap by
using the method `push` of a source defined by `request.queue` to push a request
on it, or the method `push.uri` to push an uri. For instance, consider the
following script

```{.liquidsoap include="liq/request.queue-push.liq" from=1}
```

It uses an auxiliary queue `q`, and uses the function `thread.run` to execute
every minute a function which pushes in to the queue the uri `"say:Another
minute has passed!"`. Because it begins by "`say:`" Liquidsoap will use a speech
synthesis software to turn the text into audio, as detailed below, and we will
hear "Another minute has passed" every minute, over the playlist (the `add`
operator plays simultaneously all the sources in its input list).

#### Implementation of queues

Incidentally, the function `request.queue` is implemented in Liquidsoap, by
using a list to maintain the queue of requests. Here is a slightly simplified
version of it:

```{.liquidsoap include="liq/request.queue-implementation.liq" from=1 to=-1}
```

Internally, it maintains a reference on a list called `queue`. The `next`
function pops the first element of the list and returns it (or `null` if the
queue is empty) and the `push` function adds a new request at the end of the
list. Finally, the source is created by `request.dynamic` with `next` as
function returning the next request; note that we use the labeled argument
`available` which is a boolean getter indicating whether or not the function
`next` has a meaningful next request to answer (it does not when the list is
empty). Finally, the source is returned, decorated with the method `push`.

### Protocols

We have seen that playlists can either contain files which are local or distant,
the latter beginning by prefixes such as "`http:`" or "`ftp:`". A _protocol_ is
a way of turning such a prefixed uri into an actual file. Most of the time it
will consist in downloading the file in the appropriate way, but not
only. Liquidsoap supports many protocols and even the possibility of adding your
own.

For instance, the `youtube-dl` protocol allows the use of the `youtube-dl`
program in order to download files from youtube.

```{.liquidsoap include="liq/youtube-dl.liq" from=1 to=-1}
```

when playing such a file, we need to do more than simply connect to some
particular location over the internet, and have to do tricky stuff in order to
fetch the video from youtube. Similarly, the `say` protocol uses the
text-to-speech software `text2wav` provided by the festival project in order to
synthesize speech. For instance,

```{.liquidsoap include="liq/say.liq" from=1 to=-1}
```

Incidentally, the `prefix` parameter of `playlist` can be used to add a prefix
to every element of the playlist, which is typically useful for
protocols. Typically, the following will read out the paths of the file in the
playlist:

```{.liquidsoap include="liq/say-playlist.liq" from=1 to=-1}
```

Another very useful protocol is `annotate` which adds metadata to the following
song, as in

```
annotate:artist=The artist,comment=Played on my radio:test.mp3
```

In particular, this can be used to add metadata in playlists (which can contain
files beginning with `annotate:`), to specify the usual information such as
artist and title (although those are generally already present in files), but
also internal information such as cue in and cue out time.

 More powerful, the `process` protocol allows to launch any command in order to
process files. The syntax is

```
process:<ext>,<cmd>:uri
```

where `<ext>` is the extension of the produced file, `<cmd>` is the command to
launch and `uri` is the uri of a file. In `<cmd>`, `$(input)` will be replaced
by the input file and `$(output)` by the output file (a temporary file whose
extension is `<ext>`. For instance, we can convert a file `test.mp3` in stereo
wav (even if the input file is mono) by:

```{.liquidsoap include="liq/process1.liq" from=1 to=-1}
```

When playing it, Liquidsoap will first download `test.mp3` into some place (say
`/tmp/temp.mp3`) and then execute

```
ffmpeg -y -i /tmp/temp.mp3 -ac 2 /tmp/temp.wav
```

in order to convert it to stereo wav, and then play the resulting temporary file
`/tmp/temp.wav`. The protocol `process` also accepts files of the form

```
process:<ext>,<cmd>
```

in which case only `$(output)` will be replaced in the command. For instance,
the implementation of text-to-speech in Liquidsoap essentially amounts to doing

```{.liquidsoap include="liq/process2.liq" from=1 to=-2}
```

which will run

```
echo 'Hello world!' | text2wave > /tmp/temp.wav
```

and play the resulting file.

#### Registering new protocols

One of the most powerful features of Liquidsoap is that it gives you the ability
of registering your own protocols. For instance, suppose that we have a program
`find_by_artist` which takes as argument the name of an artist and prints a
lists of music files from this artist. Typically, this would be achieved by
looking into a database of all your music files. For instance,

```
find_by_artist Halliday
```

will print

```
/data/mp3/allumer_le_feu.mp3
/data/mp3/l_envie.mp3
/data/mp3/que_je_t_aime.mp3
```

We are going to define a new protocol named `artist` so that, when playing a
file such as `artist:Halliday`, Liquidsoap will run the above command in order
to find a song. This can be done by using the `add_protocol` operator: its first
mandatory argument is the name of the protocol (here, `artist`) and the second
one is a function which takes as arguments

- a function `rlog` to log the resolution process (you can use it to print
  whatever is useful for you to debug resolution problems),
- a duration `maxtime` in seconds which the resolution should not exceed (you
  should be careful about it when querying distant servers which might take a
  long time for instance),
- the request,

and returns a list of file names (which might use any protocol again)
corresponding to the request (Liquidsoap will play one of them). In our example,
we implement the protocol as

```{.liquidsoap include="liq/add_protocol2.liq" from=1 to=-3}
```

We use the `add_protocol` to register our protocol `artist`, where the function
`artist_protocol`, which returns the list of files corresponding to a request,
simply returns the list of all the files printed by the command
`find_by_artist`. The `doc` parameter is free form documentation for the
protocol and the `syntax` parameter provides an illustration of a typical
request using this protocol (both are only for documentation purposes). Once
this defined, we can finally play songs of any artist:

```liquidsoap
s = single("artist:Haliday")
```

and, of course, an uri such as `artist:Haliday` could also be used in a playlist
or pushed in a request queue.

<!--
TODO: some other useful predefined protocols:

- s3
- annotate (detailed below)
- There is a [list of
protocols](https://www.liquidsoap.info/doc-dev/protocols.html)
-->

### Soundcard inputs

In order to input sound from a soundcard you should use functions such as
`input.alsa` or `input.pulseaudio` or `input.portaudio` depending on the library
you want to use for this: the first one is a little more efficient, because
closer to the hardware, and the second is more portable and widespread. For
instance, you can hear your voice with

```{.liquidsoap include="liq/mic.liq" from=1}
```

Basically, this scripts plays the stream generated by `input.alsa`. However, we
have to use the `buffer` operator in order to bufferize the stream coming from
the soundcard and deal with with synchronization issues between the input and
the output, as detailed in [there](#sec:clocks-ex).

If you want to use a particular device, you should use the parameter `device` of
`input.alsa`, which takes as argument a string of the form `hw:X,Y` where `X` is
the card number and `Y` is the device number. The list of all devices available
on your computer can be obtained with the command

```
aplay -l
```

On my computer this returns

```
card 0: PCH [HDA Intel PCH], device 0: ALC3246 Analog [ALC3246 Analog]
  Subdevices: 0/1
  Subdevice #0: subdevice #0
card 0: PCH [HDA Intel PCH], device 3: HDMI 0 [HDMI 0]
  Subdevices: 1/1
  Subdevice #0: subdevice #0
```

so that if I want to input from HDMI, I should use `hw:0,3` as `device`
parameter.

By default, the ALSA operators have an internal buffer in order to be able to
cope with small delays induced by the soundcard and the computer. However, you
can set the `bufferize` parameter to `false` in order to avoid that in order to
reduce latencies. For instance, if you are lucky, you can hear your voice
almost in realtime, with some flanger effect added just for fun:

```{.liquidsoap include="liq/alsa-realtime.liq" from=1}
```

Beware that by reducing the buffers, you are likely to hear audio glitches due
to the fact that blank is inserted when audio data is not ready soon enough. In
this case, you should also see the following in the logs

```
Underrun! You may minimize them by increasing the buffer size.
```

which indicates that you should buffer in order to avoid defects in the audio.

### Icecast inputs with harbor {#sec:input.harbor}

Many programs are able to stream to an Icecast server, and we can use those as
an input for Liquidsoap scripts with the `input.harbor` operator. This operator
instructs Liquidsoap to run an Icecast-compatible server, called
_harbor_\index{harbor}. Clients can then connect to it, as they would do on any
Icecast server, and the stream they send there is then available as a source in
your script. This can be useful to relay a live stream without polling the
Icecast server for it, or if you have punctual distant interventions from live
speakers or DJs (for instance the [Mixxx](https://mixxx.org/) software can be
used to easily make mixes from home). A typical setup would be

```{.liquidsoap include="liq/input.harbor.liq" from=1}
```

In this example, we use the `playlist` source by default, but we give priority
to the `live` source, which is a harbor input, available only when some client
connects to it. Apart from the parameters specifying the port and the password
to use when connecting, the unlabeled argument specifies the _mountpoint_: this
should be specified by the client when connecting, which means that a same
harbor server can simultaneously relay multiple sources, as long as they use
different mountpoints.

In order to test the above script, you can use your favorite tool to stream to
Icecast. Ours obviously being Liquidsoap, you can run the script

```{.liquidsoap include="liq/input.harbor-client.liq" from=1}
```

which will stream connect to the harbor Icecast server and stream our music
library in mp3 format.


#### Security

Since harbor exposes a server to the internet, you should be serious about
security and think thoroughly about who should be having access to this
server. The fact that the server is programmed in OCaml makes it quite unlikely
that an exploit such as a buffer overflow is possible, but one never knows.

First the list of IPs which are allowed to connect to harbor can be changed with
the following setting:

```liquidsoap
set("harbor.bind_addrs", ["0.0.0.0"])
```

It takes as argument a list of allowed IPs, the default one 0.0.0.0 meaning that
every IP is allowed.

In practice, it is often quite difficult to know in advance the IPs of all the
clients, so that the main security is given by the password which is passed as
argument of `input.harbor`: please chose it wisely, and avoid at any means the
default password `"hackme"`. Even with a strong password, the security is not
very good: if some of the clients leaks the password or you want to revoke some
a client, you have to change it for every client which is not convenient. For
this reason, the authentication can also be done through a function, which is
passed as the `auth` argument of `input.harbor` and is of type `(string, string)
-> bool`: it takes as argument the username and the password of a client trying
to log in and returns whether it should be allowed or not. Typically, you would
like to call an external script, say `harbor-auth`, which will take the username
and password as argument and print "`allowed`" if the user is allowed.

```{.liquidsoap include="liq/input.harbor-auth.liq" from=1}
```

Here, our function `auth` begins by executing the script `harbor-auth` with the
username and password as argument. Note that we use `string.quote` to escape
shell special characters, so that the user cannot introduce shell commands in
his username for instance... The `get_process_lines` function returns the list
of lines returned by our script and our function returns `true` or `false`
depending on whether this first line is "`allowed`" or not. In this way you
could easily query an external database of allowed users.

Finally, the clients should be able to determine that they are really connected
with your server and not some hacker's one. The best way to achieve that is to
use SSL certificates, which can be handled with the `input.harbor.ssl` variant
of the harbor source (it is present only if Liquidsoap has been compiled with
SSL support). The certificate can be specified with the setting
`harbor.ssl.certificate` (the setting `harbor.ssl.private_key` can also be used
to specify the private key and `harbor.ssl.password` the password to unlock the
private key). Obtaining a proper SSL certificate can be tricky. You may want to
start with a self-signed certificate first, which you can for instance obtain
from [Let's Encrypt](https://letsencrypt.org/). Alternatively, a self-signed
certificate for local testing you can use the following one-liner:

```
openssl req -x509 -newkey rsa:4096 -sha256 -nodes -keyout server.key -out server.crt -subj "/CN=localhost" -days 3650
```

### External inputs

In case you are still not satisfied (for instance, if you have very specific
needs or are the proud owner of hardware which is not widely supported), it is
possible to use any program as an input, as long as this program echoes audio on
its standard output either in wav or in raw audio format, with the operators
`input.external.wav` and `input.external.rawaudio`. Here, "raw audio" data
consists in interleaved samples encoded as signed 16 bits little-endian integers
(the use of the wav format is preferable to avoid confusions about the encoding
format). For instance, we can play a sine wave which is generated by the program
`ffmpeg` with

```{.liquidsoap include="liq/input.external.wav.liq" from=1 to=-1}
```

or with

```{.liquidsoap include="liq/input.external.rawaudio.liq" from=1 to=-1}
```

The argument `cmd` is the program which is going to be executed: here, we use
`ffmpeg` , which is instructed to generate a sine at 440 Hz (`-i
'sine=frequency=440'`) in stereo (`-acÂ 2`), encode it in wav (`-f wav`) or raw
format (`-f s16le`), and output it on the standard output (`-`).

#### Jack input

If the other program has support for it, it is possible to use
Jack\index{Jack} with the `input.jack` operator. This library is dedicated to
the communication of audio data between programs and greater stability and
precision is expected than with the above method. We do not detail it here,
because it involves some configuration (in particular, a dedicated Jack server
should be running) which is not specific to Liquidsoap.

#### GStreamer input

Finally, another very general possibility for input is to use the
`input.gstreamer.audio` operator in order to use the GStreamer\index{GStreamer}
library to generate audio. The generation itself is described through a
_pipeline_ which consists in a sequence of GStreamer operators separated by
"`!`": a pipeline "`aÂ !Â b`" means that the output of operator "`a`" should be
fed to operator "`b`". We refer the reader to the documentation of the library
for more information about it. In Liquidsoap, the pipeline can be passed in the
argument labeled `pipeline`, as expected. For instance, we can generate a sine
wave (again) with

```{.liquidsoap include="liq/input.gstreamer.liq" from=1 to=-1}
```

where we use the operator `audiotestsrc` to generate a sine, which we pipe to
the `audioamplify` operator to change its volume. Similarly, we can play the
file `test.mp3` with

```{.liquidsoap include="liq/input.gstreamer2.liq" from=1 to=-1}
```

In practice, no one would use the above example as is, because Liquidsoap
already has builtin support for using GStreamer to decode files...

Scheduling
----------

Now that we have a wide panel of sources, we need to combine them.

### Fallback {#sec:fallback}

The first way of combining sources is through the `fallback` operator, which
takes as argument a list of sources, and plays the first one which is available,
i.e.Â can produce some stream. We have already seen examples of this with request
queues ([here](#sec:request.queue)) such as

```liquidsoap
radio = fallback([queue, playlist])
```

Here, we want to play a song from the request queue when there is one, otherwise
we play songs from the playlist. By default, if we are playing a song from the
playlist and there is a new song in the queue, the operator will wait for the
current playlist song to finish before playing the one from the queue. This
behavior can be changed by setting the `track_sensitive` parameter to `false`,
in which case the song from the queue will be immediately played:

```liquidsoap
radio = fallback(track_sensitive=false, [queue, playlist])
```




Incidentally, the `mksafe` operator, which takes a fallible source and makes it
infallible, is implemented precisely using this operator:

```{.liquidsoap include="liq/mksafe.liq" from=1}
```

This operator makes the source fallback on a source streaming blank audio, which
we know will always be available, so that we stream blank when the source `s`
fails instead of failing to produce a stream.

### Switching and time predicates

Another way of selecting between sources is the `switch` operator which takes as
argument a list, whose elements are pairs consisting of a predicate and a
source. Here, each _predicate_ is function taking no argument an returning a
boolean (it is of type `()Â ->Â bool`) indicating whether the corresponding source
should be played or not. The `switch` operator will then select the first source
whose predicate returns `true`. For instance, supposing that we have two
different playlists for night and day, we could alternate between those
depending on the hour with

```{.liquidsoap include="liq/switch.liq" from=3 to=-1}
```

Here also, the `track_sensitive` parameter controls whether a change of source
only occurs at track boundaries (when `true`, which is the default) or as soon
as possible.

If you want to make sure that there is always something to play, the condition
of the last source should always be true, i.e.Â you can use `{true}`. For
instance,

```{.liquidsoap include="liq/switch2.liq" from=4 to=-1}
```

will have two special programs on morning and evening, and will default to the
`music` playlist at other times. We thus obtain the same behavior as if we had
used a `fallback` operator:

```{.liquidsoap include="liq/switch2-fallback.liq" from=4 to=-1}
```

#### Time predicates

In the above examples `{0h-7h}` is a _time predicate_: it is something which is
`true` or `false` depending on the current time. Some other examples of time
predicates are

-------------   -------------------------------------
`{11h15-13h}`   between 11h15 and 13h
`{12h}`         between 12h00 and 12h59
`{12h00}`       at 12h00
`{00m}`         on the first minute of every hour
`{00m-09m}`     on the first 10 minutes of every hour
`{2w}`          on Tuesday
`{6w-7w}`       on weekends
-------------   -------------------------------------

Above, `w` stands for weekday: 1 is Monday, 2 is Tuesday, and so on. Sunday is
both 0 and 7.

#### Other predicates

We could also use this operator to manually switch between sources. As an
illustration, suppose that we have two radio streams named `radio1` and `radio2`
then we could use a script such as

```{.liquidsoap include="liq/switch3.liq" from=6 to=6}
```

where the predicate `p` determines when `radio1` should be played. For instance,
if we want to play it when a file `select-radio` contains "`1`", we could define
it as

```{.liquidsoap include="liq/switch3.liq" from=3 to=3}
```

Another way to achieve this could be use an "interactive boolean", as detailed
in [there](#sec:telnet), and defined instead

```{.liquidsoap include="liq/switch3.liq" from=4 to=5}
```

The interactive boolean is a sort of reference whose value can be changed over
the telnet by issuing commands such as "`var.set r1 = true`", which sets the
value of the boolean named `r1` to `true`. Therefore, we can switch to radioÂ 1
by typing the command

```
echo "var.set r1 = true" | nc localhost 1234
```

and back to radioÂ 2 with

```
echo "var.set r1 = false" | nc localhost 1234
```

(or directly connecting to the telnet server and issuing the commands).

### Adding

Instead of switching between two sources, we can play them together with the
`add` operator, which takes a list of sources whose sound are to be added. For
instance, if we want to make a radio consisting of a microphone input together
with background music (which is often called a "bed"), we can define

```{.liquidsoap include="liq/add.liq" from=3 to=-1}
```

This will play the two sources `mic` and `bed` at equal volume. By default, the
volume of the output is divided by 2 (because there are 2 sources) in order not
increase the loudness too much. If you want to keep the original volume of the
sources, you should set the `normalize` parameter to `false`:

```{.liquidsoap include="liq/add2.liq" from=3 to=-1}
```

but beware that this might result into some clipping if the two sources are
loud, which is never nice to hear. The operator also offers the possibility of
weighting the sources: if we want to hear the microphone twice as loud as the
bed, we should give the microphone twice the weight of the bed. The weight of
each source can be specified in a list passed in the `weights` arguments. For
instance,

```{.liquidsoap include="liq/add3.liq" from=3 to=-1}
```

assigns the weight `2.` to `mic` and `1.` to `bed`. This is equivalent to
amplifying each of the sources with the corresponding factor, i.e.

```{.liquidsoap include="liq/add4.liq" from=3 to=-1}
```

but more efficient and natural.

As a side note, the operator `add` only adds the sources which are ready. This
means that if `mic` is taken from an harbor input such as

```{.liquidsoap include="liq/add.liq" from=1 to=1}
```

and the client did not connect or was disconnected, we will hear only the bed,
as expected.

### Jingles and ads

Jingles are short announcements, generally indicating the name of the radio or
the current show. They are quite important in order for the listener to remember
the brand of your radio and create some familiarity with the radio (the music
changes but the jingles generally remain the same). Technically, jingles are not
different from any other music source, but we give here the usual ways of
inserting those, presenting tricks which might be useful in other situations too
(in particular, ads follow basically the same techniques). We suppose here that
we have a source `music` which plays our music and a source `jingles` which
plays jingles: typically, it will be defined as

```{.liquidsoap include="liq/jingles-add.liq" from=1 to=1}
```

where `jingles` is a playlist containing all our jingles.

#### Playing only one track with `switch`

Let us begin with a quite common but tricky feature. Suppose that we want to
play a jingle at the beginning of each hour, without interrupting the current
track. One would typically write a script such as

```{.liquidsoap include="liq/jingles-once.liq" from=3 to=-1}
```

which states that when the current minute of the time is "00", we should play
the `jingles` source. But this is not really good: if a track from the music
source starts at 11h58 and ends at 12h01 then no ad will be played around
noon. In order to accommodate for this, we are tempted to widen the time
predicate and replace the second line with

```liquidsoap
    ({00m-15m}, jingles),
```

Well, this is not good either: if a track of the music source ends at 12h01, we
now hear a jingle as expected, but we actually continuously hear jingles for 14
minutes instead of hearing only one. In order to fix this, we are tempted to use
the `once` operator and change the line to

```liquidsoap
    ({00m-15m}, once(jingles)),
```

This is not good either: `once(jingles)` plays only one track from `jingles`,
but during the whole execution of the script. This means that our script will
only work as expected on the first hour, where we will correctly hear one
jingle, but on the following hours we will hear no jingle because one has
already been played.

The right solution, consist in using the `predicate.once` function: it takes a
predicate `p` as argument, and returns a predicate which is true only once each
time `p` is continuously true. In case it helps, we have illustrated in the
following figure an example of a predicate `p` over time (below) and the
resulting predicate `predicate.once(p)` over time (above):

![predicate.once](fig/predicate.once)\

This means that `predicate.once({12h00-12h15})` is a predicate which is true
once between 12h00 and 12h15. This is exactly what we were looking for, and the
script we were looking for is

```{.liquidsoap include="liq/jingles-once2.liq" from=3 to=-1}
```

As a variant, if we wanted to play a jingle every half hour, we could replace
the second line by

```liquidsoap
    ({00m-15m or 30m-45m}, once(jingles)),
```

As another variant, if we wanted to play 3 jingles, we could write

```liquidsoap
    (predicate.at_most(3, {00m-15m}), jingles),
```

where `predicate.at_most` is similar to `predicate.once`, but is true a given
number of times instead of only once (its it pointless to play 3 jingles in a
row, but this can be quite useful for ads for instance).

If we want to add the jingle on top of the currently playing music, we can use
the function `available(p, s)` which takes as arguments a predicate `p` and a
source `s` and makes the source available only when the predicate is
satisfied. We can then add the music with the jingles source made available once
every half hour as follows:

```{.liquidsoap include="liq/jingles-available.liq" from=3 to=-1}
```

#### Delaying tracks

Another approach consists in using the `delay` function which prevents a source
from being available before some time. For instance, we can play a jingle
roughly every 30 minutes with

```{.liquidsoap include="liq/jingles-delay.liq" from=3 to=-1}
```

The function `delay` above enforces that, after playing a track, the source will
not be available again before 1800 seconds (which is 30 minutes). Therefore
every time the current music track ends and more than 30 minutes has passed
since the last jingle, a new one will be inserted. As a variant, we can add the
jingle on top of the currently playing music with

```{.liquidsoap include="liq/jingles-delay2.liq" from=3 to=-1}
```

#### Rotating tracks

How often we should play jingles, instead of being based on time, can be based
on tracks. The `rotate` operator allows implementing such behaviors by
specifying that we want to play a track of such source every n tracks of such
other source. This function takes a list of sources and a list of weights
associated to each source (in the argument labeled `weight`), and selects tracks
from the sources according to the weights. For instance, in the following script

```{.liquidsoap include="liq/jingles-rotate.liq" from=3 to=-1}
```

we play `jingles` with weight `1` and `music` with weight `4`: this means that
we are going to play one jingle, then four music tracks, then one jingle, then
four music tracks, and so on. If you want something less regular, the `random`
operator can be used instead of `rotate`:


```{.liquidsoap include="liq/jingles-random.liq" from=3 to=-1}
```

It is basically a randomized version of the previous source, which will randomly
chose tracks from `jingles` and `music`, the probability of choosing a track
from the later being four times the probability of choosing a track from the
former.

The `rotate` and `random` operators can also be used to vary the contents of a
source. For instance, if we wanted our `jingles` sources to play alternatively a
jingle, a commercial and an announcement for a show, we could have defined

```{.liquidsoap include="liq/jingles-rotate2.liq" from=1 to=-1}
```

#### Triggering on metadata

A last general technique for launching jingles or ads, is to trigger them by
metadata. For instance, we want that, when the metadata "`jingle`" of a track is
set to "`true`", a jingle is inserted before the track.

TODO:
- add ads at a given time
- on a metadata (with `prepend`)

```{.liquidsoap include="liq/jingles-metadata.liq"}
```

TODO: recall annotate

#### Signaling

TODO: `predicate.signal`

### Live shows

Switch to a live show as soon as one is available. Make the show unavailable
when it is silent, and skip tracks from the normal source if they contain too
much silence.

```liquidsoap
stripped_stream = 
  strip_blank(input.http("http://myicecast:8080/live.ogg"))
fallback(track_sensitive=false,
         [stripped_stream,skip_blank(normal)])
```

Without the `track_sensitive=false` the fallback would wait the end of a track
to switch to the live. When using the blank detection operators, make sure to
fine-tune their threshold and length (float) parameters.

There are two kinds of transitions. Transitions between two different children
of a switch are not problematic. Transitions between different tracks of the
same source are more tricky, since they involve a fast forward computation of
the end of a track before feeding it to the transition function: such a thing is
only possible when only one operator is using the source, otherwise it'll get
out of sync.

Handling tracks
---------------

### Metadata

- add the year of songs in the title (`map_metadata`)
- insert metadata (in scripts, with telnet)
- log all the music files which have gone on air
```{.liquidsoap include="liq/log-songs.liq" from=1 to=-1}
```
- log the current file in JSON format (see #954)
```liquidsoap
s = mksafe(playlist("~/Music"))

def f(m)
  print("got metadata!")
  data = json_of(m)^"\n"
  file.write(data=data, append=false, perms=420, "/tmp/metatest")
end

s = on_metadata(f, s)
out(s)
```
- count the number of played music files (a reference!)
- say the last song we had on air
- the annotate protocol

*ICY metadata* is the name for the mechanism used to update
metadata in icecast's source streams.
The techniques is primarily intended for data formats that do not support in-stream
metadata, such as mp3 or AAC. However, it appears that icecast also supports
ICY metadata update for ogg/vorbis streams.

When using the ICY metadata update mechanism, new metadata are submitted separately from
the stream's data, via a http GET request. The format of the request depends on the
protocol you are using (ICY for shoutcast and icecast 1 or HTTP for icecast 2).

Starting with 1.0, you can do several interesting things with icy metadata updates
in liquidsoap. We list some of those here.

You can enable or disable icy metadata update in `output.icecast`
by setting the `icy_metadata` parameter to either `"true"`
or `"false"`. The default value is `"guess"` and does the following:

* Set `"true"` for: mp3, aac, aac+, wav
* Set `"false"` for any format using the ogg container

You may, for instance, enable icy metadata update for ogg/vorbis
streams.

The function `icy.update_metadata` implements a manual metadata update
using the ICY mechanism. It can be used independently from the `icy_metadata`
parameter described above, provided icecast supports ICY metadata for the intended stream.

For instance the following script registers a telnet command name `metadata.update`
that can be used to manually update metadata:

```
def icy_update(v) =
  # Parse the argument
  l = string.split(separator=",",v)
  def split(l,v) =
    v = string.split(separator="=",v)
    if list.length(v) >= 2 then
      list.append(l,[(list.nth(v,0,default=""),list.nth(v,1,default=""))])
    else
      l
    end
  end
  meta = list.fold(split,[],l)

  # Update metadata
  icy.update_metadata(mount="/mystream",password="hackme",
                      host="myserver.net",meta)
  "Done !"
end

server.register("update",namespace="metadata",
                 description="Update metadata",
                 usage="update title=foo,album=bar,..",
                 icy_update)
```

As usual, `liquidsoap -h icy.update_metadata` lists all the arguments
of the function.

### Annotate

TODO: annotate protocol, mention the `prefix` parameter of `playlist`

Transitions {#sec:transitions}
-----------

### Crossfade

crossfade
annotate, cue_in cue_out

Sources that support seeking can also be used to implement cue points.
The basic operator for this is `cue_cut`. Its has type:

```
(?id:string,?cue_in_metadata:string,
 ?cue_out_metadata:string,
 source(audio='#a,video='#b,midi='#c))->
    source(audio='#a,video='#b,midi='#c)
```

Its parameters are:

* `cue_in_metadata`: Metadata for cue in points, default: `"liq_cue_in"`.
* `cue_out_metadata`: Metadata for cue out points, default: `"liq_cue_out"`.
* The source to apply cue points to.

The values of cue-in and cue-out points are given in absolute
position through the source's metadata. For instance, the following
source will cue-in at 10 seconds and cue-out at 45 seconds on all its tracks:

```
s = playlist(prefix="annotate:liq_cue_in=\"10.\",liq_cue_out=\"45\":",
             "/path/to/music")

s = cue_cut(s)
```

As in the above example, you may use the `annotate` protocol to pass custom cue
points along with the files passed to Liquidsoap. This is particularly useful 
in combination with `request.dymanic` as an external script can build-up
the appropriate URI, including cue-points, based on information from your
own scheduling back-end.

Alternatively, you may use `map_metadata` to add those metadata. The operator
`map_metadata` supports seeking and passes it to its underlying source.

##### Switch-based transitions
The switch-based operators (`switch`, `fallback` and `random`) support transitions. For every child, you can specify a transition function computing the output stream when moving from one child to another. This function is given two `source` parameters: the child which is about to be left, and the new selected child. The default transition is `fun (a,b) -> b`, it simply relays the new selected child source.

Transitions have limited duration, defined by the `transition_length` parameter. Transition duration can be overriden by passing a metadata. Default field for it is `"liq_transition_length"` but it can also be set to a different value via the `override` parameter. 

Here are some possible transition functions:

```
# A simple (long) cross-fade
# Use metadata override to make sure transition is long enough.
def crossfade(a,b)
  def add_transition_length(_) =
    [("liq_transition_length","15.")]
  end

  transition =
    add(normalize=false,
          [ sequence([ blank(duration=5.),
                       fade.in(duration=10.,b) ]),
            fade.out(duration=10.,a) ])

  # Transition can have multiple tracks so only pass the metadata
  # once.
  map_first_track(map_metadata(add_transition_length),transition)
end

# Partially apply next to give it a jingle source.
# It will fade out the old source, then play the jingle.
# At the same time it fades in the new source.
# Use metadata override to make sure transition is long enough.
def next(j,a,b)
  # This assumes that the jingle is 6 seconds long
  def add_transition_length(_) =
    [("liq_transition_length","15.")]
  end

  transition =
    add(normalize=false,
	  [ sequence(merge=true,
	             [ blank(duration=3.),
	               fade.in(duration=6.,b) ]),
	    sequence([fade.out(duration=9.,a),
	              j,blank()]) ])

  map_first_track(map_metadata(add_transition_length),transition)
end

# A transition, which does a cross-fading from A to B
# No need to override duration as default value (5 seconds)
# is over crossade duration (3 seconds)
def transition(j,a,b)
  add(normalize=false,
	  [ fade.in(duration=3.,b),
	    fade.out(duration=3.,a) ])
end
```

Finally, we build a source which plays a playlist, and switches to the live show as soon as it starts, using the `transition` function as a transition. At the end of the live, the playlist comes back with a cross-fading.

```
fallback(track_sensitive=false,
	     transitions=[ crossfade, transition(jingle) ],
	     [ input.http("http://localhost:8000/live.ogg"),
	       playlist("playlist.pls") ])
```

##### Cross-based transitions
The `cross()` operator allows arbitrary transitions between tracks of a same source. Here is how to use it in order to get a cross-fade:

```
def crossfade(~start_next,~fade_in,~fade_out,s)
  fade.in = fade.in(duration=fade_in)
  fade.out = fade.out(duration=fade_out)
  fader = fun (_,_,_,_,a,b) -> add(normalize=false,[fade.in(b),fade.out(a)])
  cross(duration=start_next,fader,s)
end
my_source =
  crossfade(start_next=1.,fade_out=1.,fade_in=1.,my_source)
```

The `crossfade()` function is already in liquidsoap. Unless you need a custom one, you should never have to copy the above example. It is implemented in the scripting language, much like this example. You can find its code in `utils.liq`.

The fade-in and fade-out parameters indicate the duraction of the fading effects. The start-next parameters tells how much overlap there will be between the two tracks. If you want a long cross-fading with a smaller overlap, you should use a sequence to stick some blank section before the beginning of `b` in `fader`.
The three parameters given here are only default values, and will be overriden by values coming from the metadata tags `liq_fade_in`, `liq_fade_out` and `liq_start_next`.

For an advanced crossfading function, you can see the [crossfade documentation](crossfade.html)

### Other operators

mention the `transitions` parameter of `fallback`, e.g.Â for nice switching to
live

see also: <https://github.com/savonet/liquidsoap/issues/1541>


Signal processing
-----------------

### Normalization

normalization, replaygain (the protocol)

LADSPA plugins

Good examples:

- https://savonet-users.narkive.com/MiNy36h8/have-a-sort-of-fm-sound-with-liquidsoap

### Blank

The various functions to remove blank

### Parameters

We can obtain parameters through telnet (explain how to save the values with
persistency + harbor server) / OSC

### Stereotool

TODO.......

Outputs
-------

### Files

`output.file`, common encoding formats

It is sometimes useful (or even legally necessary) to keep a backup of an audio
stream. Storing all the stream in one file can be very impractical. In order to
save a file per hour in wav format, the following script can be used:

```
# A source to dump
# s = ...

# Dump the stream
file_name = '/archive/$(if $(title),"$(title)","Unknown archive")-%Y-%m-%d/%Y-%m-%d-%H_%M_%S.mp3'
output.file(%mp3,filename,s)
```

This will save your source into a `mp3` file with name specified by `file_name`.
In this example, we use [string interpolation](language.html) and time litterals to generate a different
file name each time new metadata are coming from `s`.


### Icecast

mention `output.harbor`

### HLS output

TODO: multiple qualities, we can convert to mono with `mean`

### Youtube

TODO: example of Youtube output, we should work out native ffmpeg youtube output

### Encode once, output multiple times

TODO: explain how to encode in mp3 and output both in a file and to Icecast without re-encoding

Monitoring the stream
---------------------

See above for logging tracks

### Blank detection

Use `on_blank` to detect blank...

Some telnet (e.g. know the current song for a source, etc.)


On GeekRadio, we play many files, some of which include bonus tracks, which
means that they end with a very long blank and then a little extra music. It's
annoying to get that on air. The `skip_blank` operator skips the
current track when a too long blank is detected, which avoids that. The typical
usage is simple:

```liquidsoap
# Wrap it with a blank skipper
source = skip_blank(source)
```

At [RadioPi](http://www.radiopi.org/) they have another problem: sometimes they
have technical problems, and while they think they are doing a live show,
they're making noise only in the studio, while only blank is on air; sometimes,
the staff has so much fun (or is it something else ?) doing live shows that they
leave at the end of the show without thinking to turn off the live, and the
listeners get some silence again. To avoid that problem we made the
`strip_blank` operators which hides the stream when it's too blank
(i.e. declare it as unavailable), which perfectly suits the typical setup used
for live shows:

```liquidsoap
interlude = single("/path/to/sorryfortheblank.ogg")
# After 5 sec of blank the microphone stream is ignored,
# which causes the stream to fallback to interlude.
# As soon as noise comes back to the microphone the stream comes
# back to the live -- thanks to track_sensitive=false.
stream = fallback(track_sensitive=false,
	              [ strip_blank(max_blank=5.,live) , interlude ])

# Put that stream to a local file
output.file(%vorbis, "/tmp/hop.ogg", stream)
```

If you don't get the difference between these two operators, you should learn
more about liquidsoap's notion of [source](sources.html).

Finally, if you need to do some custom action when there's too much blank, we
have `on_blank`:

```liquidsoap
def handler()
  system("/path/to/your/script to do whatever you want")
end
source = on_blank(handler,source)
```

### Metrics
